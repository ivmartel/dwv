{"version":3,"file":"assets/workers/rle.worker.min.js","mappings":"AAGO,MAAMA,EAgBXC,MAAAA,CACEC,EACAC,EACAC,EACAC,EACAC,EACAC,GAGA,MAAMC,EAAML,EAAgB,EAGtBM,EAAgB,IAAIC,SAASR,EAAOA,OAAQA,EAAOS,YACnDC,EAAa,IAAIC,UAAUX,EAAOA,OAAQA,EAAOS,YAEjDG,EAAe,IAAIC,YAAYV,EAAYC,EAAkBE,GAC7DQ,EAAc,IAAIH,UAAUC,GAG5BG,EAAmBR,EAAcS,SAAS,GAAG,GAGnD,IAAIC,EAAuB,EACvBC,EAAkB,EACE,IAApBd,GAAiD,IAAxBC,IAC3Ba,GAAmBd,GAET,IAARE,IACFY,GAAmBZ,GAErBW,GAAwBC,EAGxB,IAAIC,EAAc,EACdC,EAAa,EACbC,EAAY,EACZC,EAAiB,EACjBC,EAAmB,EACvB,IAAK,IAAIC,EAAU,EAAGA,EAAUT,IAAoBS,EAAS,CAInC,IAApBN,IACFG,EAAYG,EAAUN,EACJ,IAAdG,IACFE,EAAmBD,GAErBH,EAAcI,EAAmBF,EAErB,IAARf,IACFa,GAAgBE,EAAYf,GAAO,EAAI,IAK3C,MAAMmB,EACJlB,EAAcS,SAAyB,GAAfQ,EAAU,IAAQ,GAC5C,IAAIE,EACFnB,EAAcS,SAAyB,GAAfQ,EAAU,IAAQ,GACxCA,IAAYT,EAAmB,GAA+B,IAA1BW,IACtCA,EAAwB1B,EAAO2B,QAGjCP,EAAaK,EACb,IAAIG,EAAQ,EACZ,KAAOR,EAAaM,GAKlB,GAHAE,EAAQlB,EAAWU,KACjBA,EAEEQ,GAAS,GAAKA,GAAS,IAEzB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQ,IAAKC,EAE/Bf,EAAYK,GAAeT,EAAWU,KAEpCA,EACFD,GAAeF,OAEZ,GAAIW,IAAU,GAAKA,IAAU,IAAK,CAEvC,MAAME,EAAQpB,EAAWU,KACvBA,EACF,IAAK,IAAIW,EAAI,EAAGA,EAAa,EAARH,IAAaG,EAEhCjB,EAAYK,GAAeW,EAE3BX,GAAeF,CAEnB,CAGEE,EAAcG,IAChBA,EAAiBH,EAErB,CAEA,IAAIa,EAAgB,KAepB,OAdsB,IAAlB/B,EAEA+B,EADE9B,EACc,IAAIS,UAAUC,GAEd,IAAIqB,WAAWrB,GAEN,KAAlBX,IAEP+B,EADE9B,EACc,IAAIgC,WAAWtB,GAEf,IAAIuB,YAAYvB,IAI7BoB,CACT,EC9HFI,KAAKC,iBAAiB,WAAW,SAAUC,GAGzC,MAAMC,EAAU,IAAIzC,EAEpBsC,KAAKI,YAAY,CAACD,EAAQxC,OACxBuC,EAAMG,KAAKzC,OACXsC,EAAMG,KAAKC,KAAKzC,cAChBqC,EAAMG,KAAKC,KAAKxC,SAChBoC,EAAMG,KAAKC,KAAKvC,UAChBmC,EAAMG,KAAKC,KAAKtC,gBAChBkC,EAAMG,KAAKC,KAAKrC,sBAEpB,IAAG","sources":["webpack://dwv/./src/decoders/dwv/rle.js","webpack://dwv/./src/decoders/dwv/rle.worker.js"],"sourcesContent":["/**\n * RLE (Run-length encoding) decoder class.\n */\nexport class RleDecoder {\n\n  /**\n   * Decode a RLE buffer.\n   * Ref: {@link http://dicom.nema.org/dicom/2013/output/chtml/part05/sect_G.3.html}.\n   *\n   * @param {Array} buffer The buffer to decode.\n   * @param {number} bitsAllocated The bits allocated per element in the buffer.\n   * @param {boolean} isSigned Is the data signed.\n   * @param {number} sliceSize The size of a slice\n   *  (number of rows per number of columns).\n   * @param {number} samplesPerPixel The number of samples\n   *  per pixel (3 for RGB).\n   * @param {number} planarConfiguration The planar configuration.\n   * @returns {Array} The decoded buffer as a typed array.\n   */\n  decode(\n    buffer,\n    bitsAllocated,\n    isSigned,\n    sliceSize,\n    samplesPerPixel,\n    planarConfiguration) {\n\n    // bytes per element\n    const bpe = bitsAllocated / 8;\n\n    // input\n    const inputDataView = new DataView(buffer.buffer, buffer.byteOffset);\n    const inputArray = new Int8Array(buffer.buffer, buffer.byteOffset);\n    // output\n    const outputBuffer = new ArrayBuffer(sliceSize * samplesPerPixel * bpe);\n    const outputArray = new Int8Array(outputBuffer);\n\n    // first value of the RLE header is the number of segments\n    const numberOfSegments = inputDataView.getInt32(0, true);\n\n    // index increment in output array\n    let outputIndexIncrement = 1;\n    let incrementFactor = 1;\n    if (samplesPerPixel !== 1 && planarConfiguration === 0) {\n      incrementFactor *= samplesPerPixel;\n    }\n    if (bpe !== 1) {\n      incrementFactor *= bpe;\n    }\n    outputIndexIncrement *= incrementFactor;\n\n    // loop on segments\n    let outputIndex = 0;\n    let inputIndex = 0;\n    let remainder = 0;\n    let maxOutputIndex = 0;\n    let groupOutputIndex = 0;\n    for (let segment = 0; segment < numberOfSegments; ++segment) {\n      // handle special cases:\n      // - more than one sample per pixel: one segment per channel\n      // - 16bits: sort high and low bytes\n      if (incrementFactor !== 1) {\n        remainder = segment % incrementFactor;\n        if (remainder === 0) {\n          groupOutputIndex = maxOutputIndex;\n        }\n        outputIndex = groupOutputIndex + remainder;\n        // 16bits data\n        if (bpe === 2) {\n          outputIndex += (remainder % bpe ? -1 : 1);\n        }\n      }\n\n      // RLE header: list of segment sizes\n      const segmentStartIndex =\n        inputDataView.getInt32((segment + 1) * 4, true);\n      let nextSegmentStartIndex =\n        inputDataView.getInt32((segment + 2) * 4, true);\n      if (segment === numberOfSegments - 1 || nextSegmentStartIndex === 0) {\n        nextSegmentStartIndex = buffer.length;\n      }\n      // decode segment\n      inputIndex = segmentStartIndex;\n      let count = 0;\n      while (inputIndex < nextSegmentStartIndex) {\n        // get the count value\n        count = inputArray[inputIndex];\n        ++inputIndex;\n        // store according to count\n        if (count >= 0 && count <= 127) {\n          // output the next count+1 bytes literally\n          for (let i = 0; i < count + 1; ++i) {\n            // store\n            outputArray[outputIndex] = inputArray[inputIndex];\n            // increment indexes\n            ++inputIndex;\n            outputIndex += outputIndexIncrement;\n          }\n        } else if (count <= -1 && count >= -127) {\n          // output the next byte -count+1 times\n          const value = inputArray[inputIndex];\n          ++inputIndex;\n          for (let j = 0; j < -count + 1; ++j) {\n            // store\n            outputArray[outputIndex] = value;\n            // increment index\n            outputIndex += outputIndexIncrement;\n          }\n        }\n      }\n\n      if (outputIndex > maxOutputIndex) {\n        maxOutputIndex = outputIndex;\n      }\n    }\n\n    let decodedBuffer = null;\n    if (bitsAllocated === 8) {\n      if (isSigned) {\n        decodedBuffer = new Int8Array(outputBuffer);\n      } else {\n        decodedBuffer = new Uint8Array(outputBuffer);\n      }\n    } else if (bitsAllocated === 16) {\n      if (isSigned) {\n        decodedBuffer = new Int16Array(outputBuffer);\n      } else {\n        decodedBuffer = new Uint16Array(outputBuffer);\n      }\n    }\n\n    return decodedBuffer;\n  };\n\n}\n","/**\n * RLE decoder worker.\n */\n\nimport {RleDecoder} from './rle.js';\n\nself.addEventListener('message', function (event) {\n\n  // decode DICOM buffer\n  const decoder = new RleDecoder();\n  // post decoded data\n  self.postMessage([decoder.decode(\n    event.data.buffer,\n    event.data.meta.bitsAllocated,\n    event.data.meta.isSigned,\n    event.data.meta.sliceSize,\n    event.data.meta.samplesPerPixel,\n    event.data.meta.planarConfiguration)]);\n\n}, false);\n"],"names":["RleDecoder","decode","buffer","bitsAllocated","isSigned","sliceSize","samplesPerPixel","planarConfiguration","bpe","inputDataView","DataView","byteOffset","inputArray","Int8Array","outputBuffer","ArrayBuffer","outputArray","numberOfSegments","getInt32","outputIndexIncrement","incrementFactor","outputIndex","inputIndex","remainder","maxOutputIndex","groupOutputIndex","segment","segmentStartIndex","nextSegmentStartIndex","length","count","i","value","j","decodedBuffer","Uint8Array","Int16Array","Uint16Array","self","addEventListener","event","decoder","postMessage","data","meta"],"sourceRoot":""}