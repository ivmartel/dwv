## API Report File for "dwv"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import Konva from 'konva';

// @public
export function addTagsToDictionary(group: string, tags: {
    [x: string]: string[];
}): void;

// @public
export class Annotation {
    colour: string | undefined;
    getCentroid(): Point | undefined;
    getFactory(): object;
    getText(): string;
    id: string;
    init(viewController: ViewController): void;
    isCompatibleView(planeHelper: PlaneHelper): boolean;
    labelPosition: Point2D | undefined;
    mathShape: object;
    planeOrigin: Point3D | undefined;
    planePoints: Point3D[] | undefined;
    quantification: object | undefined;
    referencePoints: Point2D[] | undefined;
    referenceSopUID: string;
    setTextExpr(labelText: {
        [x: string]: string;
    }): void;
    setViewController(viewController: ViewController): void;
    textExpr: string | undefined;
    updateQuantification(): void;
}

// @public
export class AnnotationGroup {
    constructor(list?: Annotation[]);
    add(annotation: Annotation): void;
    addEventListener(type: string, callback: Function): void;
    find(id: string): Annotation | undefined;
    getColour(): string;
    getLength(): number;
    getList(): Annotation[];
    getMeta(): {
        [x: string]: any;
    };
    getMetaValue(key: string): string | object;
    hasMeta(key: string): boolean;
    isEditable(): boolean;
    remove(id: string): void;
    removeEventListener(type: string, callback: Function): void;
    setColour(colour: string): void;
    setEditable(flag: boolean): void;
    setMetaValue(key: string, value: string | object): void;
    setViewController(viewController: ViewController): void;
    update(annotation: Annotation, propKeys?: string[]): void;
}

// @public
export class AnnotationGroupFactory {
    checkElements(dataElements: {
        [x: string]: DataElement;
    }): string | undefined;
    create(dataElements: {
        [x: string]: DataElement;
    }): AnnotationGroup;
    getWarning(): string | undefined;
    toDicom(annotationGroup: AnnotationGroup, extraTags?: {
        [x: string]: any;
    }): {
        [x: string]: DataElement;
    };
}

// @public
export class App {
    abortAllLoads(): void;
    abortLoad(dataId: string): void;
    addAndRenderAnnotationData(data: DicomData, divId: string, refDataId: string): void;
    addData(data: DicomData): string;
    addDataViewConfig(dataId: string, config: ViewConfig): void;
    addDrawLayer(dataId: string, viewConfig: ViewConfig): void;
    addEventListener(type: string, callback: Function): void;
    addToUndoStack: (cmd: object) => void;
    // @deprecated
    applyJsonState(jsonState: string, dataId: string): void;
    // @deprecated
    canScroll(): boolean;
    // @deprecated
    canWindowLevel(): boolean;
    createAnnotationData(refDataId: string): DicomData;
    defaultOnKeydown: (event: KeyboardEvent) => void;
    fitToContainer(): void;
    getActiveLayerGroup(): LayerGroup | undefined;
    getAddedScale(): Scalar3D;
    getBaseScale(): Scalar3D;
    getCurrentStackIndex(): number;
    getData(dataId: string): DicomData | undefined;
    getDataIds(): string[];
    getDataIdsFromSopUids(uids: string[]): string[];
    getDataViewConfigs(): {
        [x: string]: ViewConfig[];
    };
    getDrawLayers(callbackFn?: Function): DrawLayer[];
    getDrawLayersByDataId(dataId: string): DrawLayer[];
    getLayerGroupByDivId(divId: string): LayerGroup;
    getMetaData(dataId: string): {
        [x: string]: DataElement;
    } | undefined;
    getNumberOfLayerGroups(): number;
    getOffset(): Scalar3D;
    getOverlayData(dataId: string): OverlayData | undefined;
    getStackSize(): number;
    getStyle(): object;
    getToolboxController(): ToolboxController;
    getViewConfig(dataId: string, groupDivId: string, excludeStarConfig?: boolean): ViewConfig | undefined;
    getViewConfigs(dataId: string, excludeStarConfig?: boolean): ViewConfig[];
    getViewLayers(callbackFn?: Function): ViewLayer[];
    getViewLayersByDataId(dataId: string): ViewLayer[];
    init(opt: AppOptions): void;
    // @deprecated
    initWLDisplay(): void;
    loadFiles: (files: File[]) => void;
    loadFromUri: (uri: string, options?: object) => void;
    loadImageObject: (data: any[]) => void;
    loadURLs: (urls: string[], options?: object) => void;
    onKeydown: (event: KeyboardEvent) => void;
    onResize: () => void;
    redo(): void;
    removeDataViewConfig(dataId: string, divId: string): void;
    removeEventListener(type: string, callback: Function): void;
    removeFromUndoStack: (name: string) => boolean;
    render(dataId: string, viewConfigs?: ViewConfig[]): void;
    reset(): void;
    resetDisplay(): void;
    resetLayout(): void;
    resetZoom(): void;
    setActiveLayerGroup(index: number): void;
    // @deprecated
    setColourMap(name: string): void;
    setDataViewConfigs(configs: {
        [x: string]: ViewConfig[];
    }): void;
    // @deprecated
    setDrawings(drawings: any[], drawingsDetails: any[], dataId: string): void;
    setImage(dataId: string, img: Image_2): void;
    setImageSmoothing(flag: boolean): void;
    setLayerGroupsBinders(list: string[]): void;
    // @deprecated
    setOpacity(alpha: number): void;
    setTool(tool: string): void;
    setToolFeatures(list: object): void;
    // @deprecated
    setWindowLevelPreset(preset: string): void;
    toggleOverlayListeners(dataId: string): void;
    translate(tx: number, ty: number): void;
    undo(): void;
    updateDataViewConfig(dataId: string, divId: string, config: ViewConfig): void;
    zoom(step: number, cx: number, cy: number): void;
}

// @public
export class AppOptions {
    constructor(dataViewConfigs?: {
        [x: string]: ViewConfig[];
    });
    binders: string[] | undefined;
    dataViewConfigs: {
        [x: string]: ViewConfig[];
    } | undefined;
    defaultCharacterSet: string | undefined;
    overlayConfig: object | undefined;
    rootDocument: DocumentFragment;
    tools: {
        [x: string]: ToolConfig;
    } | undefined;
    viewOnFirstLoadItem: boolean | undefined;
}

// @public (undocumented)
export namespace BLACK {
    let // (undocumented)
    r: number;
    let // (undocumented)
    g: number;
    let // (undocumented)
    b: number;
}

// @public
export function buildMultipart(parts: any[], boundary: string): Uint8Array;

// @public
export class ChangeSegmentColourCommand {
    constructor(mask: Image_2, segment: MaskSegment, newColour: RGB | number, silent?: boolean);
    execute(): void;
    getName(): string;
    isValid(): boolean;
    onExecute(_event: object): void;
    onUndo(_event: object): void;
    undo(): void;
}

// @public
export class Circle {
    constructor(centre: Point2D, radius: number);
    equals(rhs: Circle): boolean;
    getCenter(): Point2D;
    getCentroid(): Point2D;
    getRadius(): number;
    getRound(): number[][][];
    getSurface(): number;
    getWorldSurface(spacing2D: Scalar2D): number;
    quantify(viewController: ViewController, flags: string[]): object;
}

// @public
export class ColourMap {
    constructor(red: number[], green: number[], blue: number[]);
    blue: number[];
    green: number[];
    red: number[];
}

// @public
export function createImage(elements: {
    [x: string]: DataElement;
}): Image_2;

// @public
export function createMaskImage(elements: {
    [x: string]: DataElement;
}): Image_2;

// @public
export function createView(elements: {
    [x: string]: DataElement;
}, image: Image_2): View;

// @public (undocumented)
export namespace customUI {
    export function openRoiDialog(annotation: Annotation, callback: Function): void;
}

// @public
export class DataElement {
    constructor(vr: string);
    endOffset: number;
    items: any[];
    startOffset: number;
    tag: Tag;
    undefinedLength: boolean;
    value: any[];
    vl: number;
    vr: string;
}

// @public
export const decoderScripts: {
    jpeg2000: string;
    'jpeg-lossless': string;
    'jpeg-baseline': string;
    rle: string;
};

// @public
export const defaultPresets: {
    [x: string]: {
        [x: string]: WindowLevel;
    };
};

// @public (undocumented)
export namespace defaults {
    let // (undocumented)
    labelText: {
        [x: string]: {
            [x: string]: string;
        };
    };
}

// @public
export class DeleteSegmentCommand {
    constructor(mask: Image_2, segment: MaskSegment, silent?: boolean);
    execute(): void;
    getName(): string;
    isValid(): boolean;
    onExecute(_event: object): void;
    onUndo(_event: object): void;
    undo(): void;
}

// @public
export class DicomCode {
    constructor(meaning: string);
    longValue: string | undefined;
    meaning: string;
    schemeDesignator: string | undefined;
    toString(): string;
    urnValue: string | undefined;
    value: string | undefined;
}

// @public
export class DicomData {
    constructor(meta: object);
    annotationGroup: AnnotationGroup | undefined;
    image: Image_2 | undefined;
    meta: object;
}

// @public
export class DicomParser {
    getDefaultCharacterSet(): string;
    getDicomElements(): {
        [x: string]: DataElement;
    };
    parse(buffer: ArrayBuffer): void;
    setDecoderCharacterSet(characterSet: string): void;
    setDefaultCharacterSet(characterSet: string): void;
}

// @public
export class DicomSRContent {
    constructor(valueType: string);
    conceptNameCode: DicomCode | undefined;
    contentSequence: DicomSRContent[] | undefined;
    relationshipType: string;
    toString(prefix?: string): string;
    value: object;
    valueType: string;
}

// @public
export class DicomWriter {
    getBuffer(dataElements: {
        [x: string]: DataElement;
    }): ArrayBuffer;
    getElementToWrite(element: DataElement): DataElement | null;
    setFixUnknownVR(flag: boolean): void;
    setRules(rules: {
        [x: string]: WriterRule;
    }, addMissingTags?: boolean): void;
    setUseUnVrForPrivateSq(flag: boolean): void;
    useSpecialTextEncoder(): void;
}

// @public
export class DrawController {
    constructor(group?: AnnotationGroup);
    addAnnotation(annotation: Annotation): void;
    getAnnotation(id: string): Annotation | undefined;
    getAnnotationGroup(): AnnotationGroup;
    hasAnnotationMeta(key: string): boolean;
    isAnnotationGroupEditable(): boolean;
    removeAllAnnotationsWithCommand(exeCallback: Function): void;
    removeAnnotation(id: string): void;
    removeAnnotationWithCommand(id: string, exeCallback: Function): void;
    setAnnotationGroupEditable(flag: boolean): void;
    setAnnotationMeta(key: string, value: string): void;
    updateAnnotation(annotation: Annotation, propKeys?: string[]): void;
    updateAnnotationWithCommand(id: string, originalProps: object, newProps: object, exeCallback: Function): void;
}

// @public
export class DrawLayer {
    constructor(containerDiv: HTMLDivElement);
    activateCurrentPositionShapes(flag: boolean): void;
    addEventListener(type: string, callback: Function): void;
    addFlipOffsetX(): void;
    addFlipOffsetY(): void;
    bindInteraction(): void;
    // @deprecated
    deleteDraw(_id: string, _exeCallback: Function): void;
    // @deprecated
    deleteDraws(_exeCallback: Function): void;
    display(flag: boolean): void;
    draw(): void;
    fitToContainer(containerSize: Scalar2D, divToWorldSizeRatio: number, fitOffset: Scalar2D): void;
    flipScaleX(): void;
    flipScaleY(): void;
    flipScaleZ(): void;
    getBaseSize(): Scalar2D;
    getCurrentPosGroup(): Konva.Group | undefined;
    getDataId(): string;
    getDrawController(): DrawController;
    getGroup(id: string): object | undefined;
    getId(): string;
    getKonvaLayer(): Konva.Layer;
    getKonvaStage(): Konva.Stage;
    getNumberOfDraws(): number | undefined;
    getOpacity(): number;
    getReferenceLayerId(): string;
    initialise(size: Scalar2D, spacing: Scalar2D, refLayerId: string): void;
    initScale(newScale: Scalar3D, absoluteZoomOffset: Scalar2D): void;
    isAnnotationVisible(id: string): boolean;
    isVisible(): boolean;
    removeEventListener(type: string, callback: Function): void;
    removeFromDOM(): void;
    setAnnotationGroup(annotationGroup: AnnotationGroup, dataId: string, exeCallback: object): void;
    setAnnotationVisibility(id: string, visible?: boolean): boolean;
    setBaseOffset(scrollOffset: Vector3D, planeOffset: Vector3D): boolean;
    setCurrentPosition(position: Point, index: Index): boolean;
    setLabelsVisibility(visible?: boolean): void;
    setLabelVisibility(shapeGroup: Konva.Group): void;
    setOffset(newOffset: Scalar3D): void;
    setOpacity(alpha: number): void;
    setPlaneHelper(helper: PlaneHelper): void;
    setScale(newScale: Scalar3D, center?: Point3D): void;
    setShapeHandler(handler: DrawShapeHandler | undefined): void;
    unbindInteraction(): void;
}

// @public
export class DrawShapeHandler {
    constructor(app: App, eventCallback: Function);
    addShapeListeners(drawLayer: DrawLayer, shapeGroup: Konva.Group, annotation: Annotation): void;
    disableAndResetEditor(): void;
    getEditorAnnotation(): Annotation | undefined;
    getEditorShapeGroup(): Konva.Group | undefined;
    onMouseOutShapeGroup(): void;
    removeShapeListeners(shapeGroup: Konva.Group): void;
    setEditorShape(shape: Konva.Shape, drawLayer: DrawLayer): void;
    storeMouseOverCursor(cursor: string): void;
}

// @public
export class Ellipse {
    constructor(centre: Point2D, a: number, b: number);
    equals(rhs: Ellipse): boolean;
    getA(): number;
    getB(): number;
    getCenter(): Point2D;
    getCentroid(): Point2D;
    getRound(): number[][][];
    getSurface(): number;
    getWorldSurface(spacing2D: Scalar2D): number;
    quantify(viewController: ViewController, flags: string[]): object;
}

// @public
export class Geometry {
    constructor(origin: Point3D, size: Size, spacing: Spacing, orientation?: Matrix33, time?: number);
    appendFrame(origin: Point3D, time: number): void;
    appendOrigin(origin: Point3D, index: number, time?: number): void;
    equals(rhs: Geometry): boolean;
    getCurrentNumberOfSlicesBeforeTime(time: number): number | undefined;
    getCurrentTotalNumberOfSlices(): number;
    getInitialTime(): number;
    getOrientation(): Matrix33;
    getOrigin(): Point3D;
    getOrigins(): Point3D[];
    getRealSpacing(): Spacing;
    getSize(viewOrientation?: Matrix33): Size;
    getSliceIndex(point: Point3D, time: number): number;
    getSpacing(viewOrientation?: Matrix33): Spacing;
    hasSlicesAtTime(time: number): boolean;
    includesOrigin(point3D: Point3D, tol: number): boolean;
    indexToWorld(index: Index): Point;
    isInBounds(point: Point): boolean;
    isIndexInBounds(index: Index, dirs?: number[]): boolean;
    pointToWorld(point: Point3D): Point3D;
    toString(): string;
    worldToIndex(point: Point): Index;
    worldToPoint(point: Point): Point3D;
}

// @public
export function getDefaultDicomSegJson(): object;

// @public
export function getDicomSRContentItem(content: DicomSRContent): {
    [x: string]: any;
};

// @public
export function getDwvVersion(): string;

// @public
export function getElementsFromJSONTags(simpleTags: {
    [x: string]: any;
}): {
    [x: string]: DataElement;
};

// @public
export function getEllipseIndices(center: Index, radius: number[], dir: number[]): Index[];

// @public
export function getLayerDetailsFromEvent(event: object): object;

// @public
export function getMousePoint(event: object): Point2D;

// @public
export function getOrientationName(orientation: number[]): string | undefined;

// @public
export function getPixelDataTag(): Tag;

// @public
export function getReverseOrientation(ori: string): string;

// @public
export function getSRContent(dataElements: {
    [x: string]: DataElement;
}): DicomSRContent;

// @public
export function getTagFromKey(key: string): Tag;

// @public
export function getTouchPoints(event: object): Point2D[];

// @public
export function getTypedArray(bitsAllocated: number, pixelRepresentation: number, size: number): Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array;

// @public
export function getUID(tagName: string): string;

// @public
export function hasDicomPrefix(buffer: ArrayBuffer): boolean;

// @public (undocumented)
export namespace i18n {
    export function t(key: string): string;
}

// @public
class Image_2 {
    constructor(geometry: Geometry, buffer: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, imageUids?: string[]);
    addEventListener(type: string, callback: Function): void;
    appendFrame(time: number, origin: Point3D): void;
    appendFrameBuffer(frameBuffer: object, frameIndex: number): void;
    appendSlice(rhs: Image_2): void;
    calculateDataRange(): object;
    calculateHistogram(): object;
    calculateRescaledDataRange(): object;
    canQuantify(): boolean;
    canScroll(viewOrientation: Matrix33): boolean;
    // @deprecated
    canWindowLevel(): boolean;
    clone(): Image_2;
    compose(rhs: Image_2, operator: Function): Image_2;
    containsImageUids(uids: string[]): boolean;
    convolute2D(weights: number[]): Image_2;
    convoluteBuffer(weights: number[], buffer: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, startOffset: number): void;
    getBuffer(): Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array;
    getDataRange(): NumberRange;
    getGeometry(): Geometry;
    getHistogram(): any[];
    getImageUid(index?: Index): string;
    getMeta(): {
        [x: string]: any;
    };
    getNumberOfComponents(): number;
    getOffsets(value: number | RGB): number[];
    getOriginForImageUid(uid: string): Point3D | undefined;
    getPhotometricInterpretation(): string;
    getPlanarConfiguration(): number;
    getRescaledDataRange(): NumberRange;
    getRescaledValue(i: number, j: number, k: number, f: number): number;
    getRescaledValueAtIndex(index: Index): number;
    getRescaledValueAtOffset(offset: number): number;
    getRescaleSlopeAndIntercept(index?: Index): RescaleSlopeAndIntercept;
    getSecondaryOffset(index: Index): number;
    getValue(i: number, j: number, k: number, f: number): number;
    getValueAtIndex(index: Index): number;
    getValueAtOffset(offset: number): number;
    hasValues(values: any[]): boolean[];
    includesImageUid(uid: string): boolean;
    isConstantRSI(): boolean;
    isIdentityRSI(): boolean;
    isMonochrome(): boolean;
    removeEventListener(type: string, callback: Function): void;
    setAtOffsets(offsets: number[], value: number | RGB): void;
    setAtOffsetsAndGetOriginals(offsetsLists: number[][], value: RGB): any[];
    setAtOffsetsWithIterator(offsetsLists: number[][], value: RGB | any[]): void;
    setMeta(rhs: {
        [x: string]: any;
    }): void;
    setPhotometricInterpretation(interp: string): void;
    setPlanarConfiguration(config: number): void;
    setRescaleSlopeAndIntercept(inRsi: RescaleSlopeAndIntercept, offset?: number): void;
    transform(operator: Function): Image_2;
}
export { Image_2 as Image }

// @public
export class Index {
    constructor(values: number[]);
    add(rhs: Index): Index;
    canCompare(rhs: Index): boolean;
    compare(rhs: Index): number[];
    equals(rhs: Index): boolean;
    get(i: number): number | undefined;
    getValues(): number[];
    getWithNew2D(i: number, j: number): Index;
    length(): number;
    toString(): string;
}

// @public
export function isEqualRgb(c1: RGB, c2: RGB): boolean;

// @public
export function labToUintLab(triplet: object): object;

// @public
export class LayerGroup {
    constructor(containerDiv: HTMLElement);
    addDrawLayer(): DrawLayer;
    addEventListener(type: string, callback: Function): void;
    addScale(scaleStep: number, center: Point3D): void;
    addTranslation(translation: Scalar3D): void;
    addViewLayer(): ViewLayer;
    canScroll(): boolean;
    display(flag: boolean): void;
    draw(): void;
    empty(): void;
    fitToContainer(divToWorldSizeRatio: number): void;
    flipScaleZ(): void;
    getActiveDrawLayer(): DrawLayer | undefined;
    getActiveViewLayer(): ViewLayer | undefined;
    getAddedScale(): Scalar3D;
    getBaseScale(): Scalar3D;
    getBaseViewLayer(): ViewLayer | undefined;
    getDivId(): string;
    getDivToWorldSizeRatio(): number | undefined;
    getDrawLayers(callbackFn?: Function): DrawLayer[];
    getDrawLayersByDataId(dataId: string): DrawLayer[];
    getMaxWorldSize(): Scalar2D | undefined;
    getNumberOfLayers(): number;
    getNumberOfViewLayers(): number;
    getOffset(): Scalar3D;
    getScale(): Scalar3D;
    getShowCrosshair(): boolean;
    getViewDataIndices(): string[];
    getViewLayers(callbackFn?: Function): ViewLayer[];
    getViewLayersByDataId(dataId: string): ViewLayer[];
    includes(id: string): boolean;
    isPositionInBounds(position: Point): boolean;
    moreThanOne(dim: number): boolean;
    removeEventListener(type: string, callback: Function): void;
    removeLayer(layer: ViewLayer | DrawLayer): void;
    removeLayersByDataId(dataId: string): void;
    removeTooltipDiv(): void;
    reset(): void;
    searchViewLayers(meta: object): ViewLayer[];
    setActiveDrawLayer(index: number | undefined): void;
    setActiveDrawLayerByDataId(dataId: string): void;
    setActiveViewLayer(index: number): void;
    setActiveViewLayerByDataId(dataId: string): void;
    setImageSmoothing(flag: boolean): void;
    setOffset(newOffset: Scalar3D): void;
    setScale(newScale: Scalar3D, center?: Point3D): void;
    setShowCrosshair(flag: boolean): void;
    showTooltip(point: Point2D): void;
    someViewLayer(callbackFn: Function): boolean;
    updateLayersToPositionChange: (event: object) => void;
}

// @public (undocumented)
export namespace logger {
    // (undocumented)
    export function debug(msg: string): void;
    let // (undocumented)
    level: number;
    // (undocumented)
    export function error(msg: string): void;
    // (undocumented)
    export function info(msg: string): void;
    // (undocumented)
    export namespace levels {
        let // (undocumented)
        TRACE: number;
        let // (undocumented)
        DEBUG: number;
        let // (undocumented)
        INFO: number;
        let // (undocumented)
        WARN: number;
        let // (undocumented)
        ERROR: number;
    }
    // (undocumented)
    export function trace(msg: string): void;
    // (undocumented)
    export function warn(msg: string): void;
}

// @public
export const luts: {
    [x: string]: ColourMap;
};

// @public
export class MaskFactory {
    checkElements(_dicomElements: {
        [x: string]: DataElement;
    }): string | undefined;
    create(dataElements: {
        [x: string]: DataElement;
    }, pixelBuffer: Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array): Image_2;
    getWarning(): string | undefined;
    toDicom(image: Image_2, segments: MaskSegment[], sourceImage: Image_2, extraTags?: {
        [x: string]: any;
    }): {
        [x: string]: DataElement;
    };
}

// @public
export class MaskSegment {
    constructor(number: number, label: string, algorithmType: string);
    algorithmName: string | undefined;
    algorithmType: string;
    displayRGBValue: RGB | undefined;
    displayValue: number | undefined;
    label: string;
    number: number;
    propertyCategoryCode: DicomCode | undefined;
    propertyTypeCode: DicomCode | undefined;
    trackingId: string | undefined;
    trackingUid: string | undefined;
}

// @public
export class MaskSegmentHelper {
    constructor(mask: Image_2);
    addSegment(segment: MaskSegment): void;
    getNumberOfSegments(): number;
    getSegment(segmentNumber: number): MaskSegment | undefined;
    hasSegment(segmentNumber: number): boolean;
    maskHasSegments(numbers: number[]): boolean[];
    removeSegment(segmentNumber: number): void;
    updateSegment(segment: MaskSegment): void;
}

// @public
export class MaskSegmentViewHelper {
    addToHidden(segment: MaskSegment): void;
    getAlphaFunc(): (value: number[] | number, index: number) => number;
    isHidden(segmentNumber: number): boolean;
    removeFromHidden(segmentNumber: number): void;
}

// @public
export class Matrix33 {
    constructor(values: number[]);
    asOneAndZeros(): Matrix33;
    equals(rhs: Matrix33, p?: number): boolean;
    get(row: number, col: number): number | undefined;
    getAbs(): Matrix33;
    getColAbsMax(col: number): object;
    getInverse(): Matrix33 | undefined;
    getRowAbsMax(row: number): object;
    getThirdColMajorDirection(): number;
    multiply(rhs: Matrix33): Matrix33;
    multiplyArray3D(array3D: number[]): number[];
    multiplyIndex3D(index3D: Index): Index;
    multiplyPoint3D(point3D: Point3D): Point3D;
    multiplyVector3D(vector3D: Vector3D): Vector3D;
    toString(): string;
}

// @public
export class NumberRange {
    constructor(min: number, max: number);
    max: number;
    min: number;
}

// @public (undocumented)
export namespace Orientation {
    let // (undocumented)
    Axial: string;
    let // (undocumented)
    Coronal: string;
    let // (undocumented)
    Sagittal: string;
}

// @public
export class OverlayData {
    constructor(app: App, dataId: string, configs: object);
    addAppListeners(): void;
    addEventListener(type: string, callback: object): void;
    addItemMeta(data: object): void;
    isListening(): boolean;
    removeAppListeners(): void;
    removeEventListener(type: string, callback: object): void;
    reset(): void;
}

// @public
export class PlaneHelper {
    constructor(imageGeometry: Geometry, viewOrientation: Matrix33);
    getImageDeOrientedPoint3D(point: Point3D): Point3D;
    getImageDeOrientedVector3D(vector: Vector3D): Vector3D;
    getImageOrientedPoint3D(planePoint: Point3D): Point3D;
    getImageOrientedVector3D(planeVector: Vector3D): Vector3D;
    getNativeScrollIndex(): number;
    getOffset3DFromPlaneOffset(offset2D: Scalar2D): Vector3D;
    getPlaneOffsetFromOffset3D(offset3D: Scalar3D): Scalar2D;
    getPlanePoints(k: number): Point3D[];
    getPositionFromPlanePoint(point2D: Point2D, k: number): Point3D;
    getScrollIndex(): number;
    getTargetDeOrientedPoint3D(planePoint: Point3D): Point3D;
    getTargetDeOrientedVector3D(planeVector: Vector3D): Vector3D;
    getTargetOrientedPositiveXYZ(values: Scalar3D): Scalar3D;
    getTargetOrientedVector3D(vector: Vector3D): Vector3D;
    isAquisitionOrientation(): boolean;
    worldToIndex(point: Point): Index;
}

// @public
export class Point {
    constructor(values: number[]);
    add(rhs: Point): Point;
    canCompare(rhs: Point): boolean;
    compare(rhs: Point): number[];
    equals(rhs: Point): boolean;
    get(i: number): number;
    get3D(): Point3D;
    getValues(): number[];
    length(): number;
    mergeWith3D(rhs: Point3D): Point;
    toString(): string;
}

// @public
export class Point2D {
    constructor(x: number, y: number);
    equals(rhs: Point2D): boolean;
    getCentroid(): Point2D;
    getDistance(point2D: Point2D): number;
    getX(): number;
    getY(): number;
    toString(): string;
}

// @public
export class Point3D {
    constructor(x: number, y: number, z: number);
    equals(rhs: Point3D): boolean;
    getClosest(pointList: Point3D[]): number;
    getDistance(point3D: Point3D): number;
    getX(): number;
    getY(): number;
    getZ(): number;
    isSimilar(rhs: Point3D, tol: number): boolean;
    minus(point3D: Point3D): Vector3D;
    toString(): string;
}

// @public
export function precisionRound(number: number, precision: number): number;

// @public
export class Protractor {
    constructor(points: Point2D[]);
    getCentroid(): Point2D;
    getLength(): number;
    getPoint(index: number): Point2D | undefined;
    quantify(_viewController: ViewController, _flags: string[]): object;
}

// @public
export class Rectangle {
    constructor(begin: Point2D, end: Point2D);
    equals(rhs: Rectangle): boolean;
    getBegin(): Point2D;
    getCentroid(): Point2D;
    getEnd(): Point2D;
    getHeight(): number;
    getRealHeight(): number;
    getRealWidth(): number;
    getRound(): object;
    getSurface(): number;
    getWidth(): number;
    getWorldSurface(spacing2D: Scalar2D): number;
    quantify(viewController: ViewController, flags: string[]): object;
}

// @public
export class RescaleSlopeAndIntercept {
    constructor(slope: number, intercept: number);
    apply(value: number): number;
    equals(rhs: RescaleSlopeAndIntercept): boolean;
    getIntercept(): number;
    getSlope(): number;
    isID(): boolean;
}

// @public
export class RGB {
    constructor(r: number, g: number, b: number);
    b: number;
    g: number;
    r: number;
}

// @public
export class ROI {
    constructor(points?: Point2D[]);
    addPoint(point: Point2D): void;
    addPoints(rhs: Point2D[]): void;
    getCentroid(): Point2D;
    getLength(): number;
    getPoint(index: number): Point2D | undefined;
    getPoints(): Point2D[];
}

// @public
export class Scalar2D {
    x: number;
    y: number;
}

// @public
export class Scalar3D {
    x: number;
    y: number;
    z: number;
}

// @public
export class ScrollWheel {
    constructor(app: App);
    wheel(event: WheelEvent): void;
}

// @public
export class Size {
    constructor(values: number[]);
    canScroll(viewOrientation: Matrix33): boolean;
    canScroll3D(viewOrientation?: Matrix33): boolean;
    equals(rhs: Size): boolean;
    get(i: number): number;
    get2D(): Scalar2D;
    getDimSize(dimension: number, start?: number): number;
    getTotalSize(start?: number): number;
    getValues(): number[];
    indexToOffset(index: Index, start?: number): number;
    isInBounds(index: Index, dirs: number[]): boolean;
    length(): number;
    moreThanOne(dimension: number): boolean;
    offsetToIndex(offset: number): Index;
    toString(): string;
}

// @public
export class Spacing {
    constructor(values: number[]);
    equals(rhs: Spacing): boolean;
    get(i: number): number;
    get2D(): Scalar2D;
    getValues(): number[];
    length(): number;
    toString(): string;
}

// @public
export function srgbToCielab(triplet: RGB): object;

// @public
export class Tag {
    constructor(group: string, element: string);
    equals(rhs: Tag): boolean;
    getElement(): string;
    getGroup(): string;
    getGroupName(): string;
    getKey(): string;
    getNameFromDictionary(): string | undefined;
    getVrFromDictionary(): string | undefined;
    isPrivate(): boolean;
    isWithVR(): boolean;
    toString(): string;
}

// @public
export class TagValueExtractor {
    getTime(_elements: {
        [x: string]: DataElement;
    }): number | undefined;
}

// @public
export class ToolboxController {
    constructor(toolList: object);
    bindLayerGroup(layerGroup: LayerGroup, layer: ViewLayer | DrawLayer): void;
    enableShortcuts(flag: boolean): void;
    getSelectedTool(): object;
    getSelectedToolEventHandler(eventType: string): Function;
    getToolList(): any[];
    hasTool(name: string): boolean;
    init(): void;
    setSelectedTool(name: string): void;
    setToolFeatures(list: object): void;
}

// @public
export class ToolConfig {
    constructor(options?: string[]);
    options: string[] | undefined;
}

// @public
export const toolList: {
    [x: string]: any;
};

// @public
export const toolOptions: {
    [x: string]: {
        [x: string]: any;
    };
};

// @public
export class Vector3D {
    constructor(x: number, y: number, z: number);
    crossProduct(vector3D: Vector3D): Vector3D;
    dotProduct(vector3D: Vector3D): number;
    equals(rhs: Vector3D): boolean;
    getX(): number;
    getY(): number;
    getZ(): number;
    isCodirectional(vector3D: Vector3D): boolean;
    norm(): number;
    toString(): string;
}

// @public
export class View {
    constructor(image: Image_2);
    addEventListener(type: string, callback: Function): void;
    addWindowPresets(presets: object): void;
    generateImageData(data: ImageData, index: Index): void;
    getAlphaFunction(): (value: number[] | number, index: number) => number;
    getColourMap(): string;
    getCurrentImageUid(): string;
    getCurrentIndex(): Index;
    getCurrentPosition(): Point;
    getCurrentWindowPresetName(): string;
    getImage(): Image_2;
    getOrientation(): Matrix33;
    getOrigin(position?: Point): Point3D;
    getOriginForImageUid(uid: string): Point3D | undefined;
    getPlaybackMilliseconds(recommendedDisplayFrameRate: number): number;
    getScrollIndex(): number;
    getWindowLevel(): WindowLevel;
    getWindowLevelMinMax(): WindowLevel;
    getWindowPresets(): object;
    getWindowPresetsNames(): string[];
    includesImageUid(uid: string): boolean;
    init(): void;
    isAquisitionOrientation(): boolean;
    isPositionInBounds(position?: Point): boolean;
    removeEventListener(type: string, callback: Function): void;
    setAlphaFunction(func: (value: number[] | number, index: number) => number): void;
    setColourMap(name: string): void;
    setCurrentIndex(index: Index, silent?: boolean): boolean;
    setCurrentPosition(position: Point, silent: boolean): boolean;
    setImage(inImage: Image_2): void;
    setInitialIndex(): void;
    setOrientation(mat33: Matrix33): void;
    setWindowLevel(wl: WindowLevel, name?: string, silent?: boolean): void;
    setWindowLevelMinMax(): void;
    setWindowLevelPreset(name: string, silent?: boolean): void;
    setWindowLevelPresetById(id: number, silent?: boolean): void;
    setWindowPresets(presets: object): void;
}

// @public
export class ViewConfig {
    constructor(divId: string);
    colourMap: string | undefined;
    divId: string;
    opacity: number | undefined;
    orientation: string | undefined;
    windowCenter: number | undefined;
    windowWidth: number | undefined;
    wlPresetName: string | undefined;
}

// @public
export class ViewController {
    constructor(view: View);
    addWindowLevelPresets(presets: object): object;
    bindImageAndLayer(viewLayer: ViewLayer): void;
    canQuantifyImage(): boolean;
    canScroll(): boolean;
    // @deprecated
    canWindowLevel(): boolean;
    decrementIndex(dim: number, silent?: boolean): boolean;
    decrementScrollIndex(silent?: boolean): boolean;
    equalImageMeta(meta: object): boolean;
    generateImageData(array: ImageData, index?: Index): void;
    get2DSpacing(): Scalar2D;
    getColourMap(): string;
    getCurrentImageUid(): string;
    getCurrentIndex(): Index;
    getCurrentOrientedIndex(): Index;
    getCurrentPosition(): Point;
    getCurrentScrollIndexValue(): object;
    getCurrentScrollPosition(): object;
    getCurrentWindowPresetName(): string;
    getDecrementPosition(dim: number): Point;
    getDecrementScrollPosition(): Point;
    getImageRegionValues(min: Point2D, max: Point2D): any[];
    getImageRescaledDataRange(): object;
    getImageSize(): Size;
    getImageVariableRegionValues(regions: number[][][]): any[];
    getImageWorldSize(): Scalar2D;
    getIncrementPosition(dim: number): Point;
    getIncrementScrollPosition(): Point;
    getIndexFromPosition(point: Point): Index;
    getModality(): string;
    getOffset3DFromPlaneOffset(offset2D: Scalar2D): Vector3D;
    getOrigin(position?: Point): Point3D;
    getOriginForImageUid(uid: string): Point3D | undefined;
    getPixelUnit(): string;
    getPlaneHelper(): PlaneHelper;
    getPlanePoints(k: number): Point3D[];
    getPlanePositionFromPlanePoint(point2D: Point2D): Point3D;
    getPlanePositionFromPosition(point: Point): Point2D;
    getPositionFromPlanePoint(point2D: Point2D, k?: number): Point;
    getRescaledImageValue(position: Point): number | undefined;
    getScrollIndex(): number;
    getWindowLevel(): WindowLevel;
    getWindowLevelPresetsNames(): string[];
    includesImageUid(uid: string): boolean;
    incrementIndex(dim: number, silent?: boolean): boolean;
    incrementScrollIndex(silent?: boolean): boolean;
    initialise(): void;
    isAquisitionOrientation(): boolean;
    isMask(): boolean;
    isMonochrome(): boolean;
    isPlaying(): boolean;
    isPositionInBounds(position?: Point): boolean;
    moreThanOne(dim: number): boolean;
    play(): void;
    setColourMap(name: string): void;
    setCurrentIndex(index: Index, silent?: boolean): boolean;
    setCurrentPosition(pos: Point, silent?: boolean): boolean;
    setImage(img: Image_2): void;
    setViewAlphaFunction(func: (value: number[] | number, index: number) => number): void;
    setWindowLevel(wl: WindowLevel): void;
    setWindowLevelPreset(name: string): void;
    setWindowLevelPresetById(id: number): void;
    stop(): void;
    unbindImageAndLayer(viewLayer: ViewLayer): void;
}

// @public
export class ViewLayer {
    constructor(containerDiv: HTMLElement);
    addEventListener(type: string, callback: Function): void;
    addFlipOffsetX(): void;
    addFlipOffsetY(): void;
    bindImage(): void;
    bindInteraction(): void;
    clear(): void;
    display(flag: boolean): void;
    displayToMainPlanePos(point2D: Point2D): Point2D;
    displayToPlaneIndex(point2D: Point2D): Index;
    displayToPlanePos(point2D: Point2D): Point2D;
    displayToPlaneScale(point2D: Point2D): Point2D;
    draw(): void;
    fitToContainer(containerSize: Scalar2D, divToWorldSizeRatio: number, fitOffset: Scalar2D): void;
    flipScaleX(): void;
    flipScaleY(): void;
    flipScaleZ(): void;
    getAbsoluteZoomOffset(): Scalar2D;
    getBaseSize(): Scalar2D;
    getDataId(): string;
    getId(): string;
    getImageData(): object;
    getImageWorldSize(): Scalar2D;
    getOpacity(): number;
    getScale(): Scalar2D;
    getViewController(): ViewController;
    initialise(size: Scalar2D, spacing: Scalar2D, alpha: number): void;
    initScale(newScale: Scalar3D, absoluteZoomOffset: Scalar2D): void;
    isVisible(): boolean;
    onimagecontentchange: (event: object) => void;
    onimagegeometrychange: (event: object) => void;
    onimageset: (event: object) => void;
    planePosToDisplay(point2D: Point2D): Point2D;
    removeEventListener(type: string, callback: Function): void;
    removeFromDOM(): void;
    setBaseOffset(scrollOffset: Vector3D, planeOffset: Vector3D, layerGroupOrigin?: Point3D, layerGroupOrigin0?: Point3D): boolean;
    setCurrentPosition(position: Point, _index: Index): boolean;
    setImageSmoothing(flag: boolean): void;
    setOffset(newOffset: Scalar3D): void;
    setOpacity(alpha: number): void;
    setScale(newScale: Scalar3D, center?: Point3D): void;
    setView(view: object, dataId: string): void;
    unbindImage(): void;
    unbindInteraction(): void;
}

// @public
export class WindowLevel {
    constructor(center: number, width: number);
    center: number;
    equals(rhs: WindowLevel): boolean;
    width: number;
}

// @public
export class WriterRule {
    constructor(action: string);
    action: string;
    value: any | undefined;
}

// (No @packageDocumentation comment for this package)

```
