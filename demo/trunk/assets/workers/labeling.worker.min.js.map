{"version":3,"file":"assets/workers/labeling.worker.min.js","mappings":"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","sources":["webpack://dwv/./src/image/labelingFilter.js","webpack://dwv/./src/image/labeling.worker.js"],"sourcesContent":["/**\n * Filter for calculating labels.\n *\n * Labels a buffer using the Hoshen窶適opelman\n * algorithm to first label all of the connected components, then does\n * a second pass to count the number of voxels in each unique label.\n *\n * The Hoshen窶適opelman labelling is slightly modified to work with\n * non-binary 3D data, but is otherwise structured the same way.\n *\n * Ref: {@link https://en.wikipedia.org/wiki/Hoshen%E2%80%93Kopelman_algorithm}.\n */\nexport class LabelingFilter {\n  /**\n   * The last known image size.\n   *\n   * @type {number}\n   */\n  #lastKnownTotalSize;\n\n  /**\n   * A union-find (disjoint-set) representing the available labels.\n   *\n   * @type {Int32Array}\n   */\n  #unionFind;\n\n  /**\n   * A buffer containing the labels for each voxel.\n   *\n   * @type {Int32Array}\n   */\n  #labels;\n\n  /**\n   * Union-find find operation.\n   * Ref: {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}.\n   *\n   * @param {number} label The label to find the root of.\n   * @returns {number} The root label.\n   */\n  #find(label) {\n    if (label < 0) {\n      return label;\n    }\n\n    // Find the root label\n    let currentLabel = label;\n    while (this.#unionFind[currentLabel] !== currentLabel) {\n      currentLabel = this.#unionFind[currentLabel];\n    }\n\n    // Do an update pass to make this faster next time\n    let updateLabel = label;\n    while (this.#unionFind[updateLabel] !== updateLabel) {\n      const newLabel = this.#unionFind[updateLabel];\n      this.#unionFind[updateLabel] = currentLabel;\n      updateLabel = newLabel;\n    }\n\n    return currentLabel;\n  }\n\n  /**\n   * Union-find union operation.\n   *\n   * @param {number} label1 The child label to union.\n   * @param {number} label2 The parent label to union.\n   */\n  #union(label1, label2) {\n    // This will break if a non-label (-1) get passed in\n    // however with the current implmentation this should never happen\n    this.#unionFind[this.#find(label1)] = this.#find(label2);\n  }\n\n  /**\n   * Label the buffer using the Hoshen窶適opelman algorithm.\n   *\n   * @param {TypedArray} buffer The image buffer to regenerate the labels for.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} sizes The image dimensions.\n   * @param {number} totalSize The total length of the buffer.\n   */\n  #regenerateLabels(buffer, unitVectors, sizes, totalSize) {\n    // If we are re-calcing the labels of the same sized image as last time we\n    // can save a little time on re-initializing memory. Makes it slightly\n    // faster to use a seperate worker object per segmentation, at the\n    // cost of extra memory.\n    if (typeof this.#lastKnownTotalSize === 'undefined' ||\n        this.#lastKnownTotalSize !== totalSize) {\n      // The size of the image has changed, we need to reinitialize everything.\n      this.#lastKnownTotalSize = totalSize;\n\n      // Performance trade-off means this can use a fair bit of memory\n      // on large images.\n      this.#unionFind = new Int32Array(totalSize);\n      this.#labels = new Int32Array(totalSize);\n    }\n\n    // Generate the Hoshen窶適opelman labels\n    for (let x = 0; x < sizes[0]; x++) {\n      for (let y = 0; y < sizes[1]; y++) {\n        for (let z = 0; z < sizes[2]; z++) {\n\n          const thisOffset =\n            (unitVectors[0] * x) +\n            (unitVectors[1] * y) +\n            (unitVectors[2] * z);\n\n          // Reset labels.\n          this.#unionFind[thisOffset] = thisOffset;\n          this.#labels[thisOffset] = -1;\n\n          const thisValue = buffer[thisOffset];\n\n          if (thisValue > 0) {\n            // Neighbor offsets\n            const xOffset = thisOffset - unitVectors[0];\n            const yOffset = thisOffset - unitVectors[1];\n            const zOffset = thisOffset - unitVectors[2];\n\n            // Neighbor values\n            let xValue = 0;\n            if (x > 0) {\n              xValue = buffer[xOffset];\n            };\n            let yValue = 0;\n            if (y > 0) {\n              yValue = buffer[yOffset];\n            };\n            let zValue = 0;\n            if (z > 0) {\n              zValue = buffer[zOffset];\n            };\n\n            // Neighbor labels\n            let xLabel = 0;\n            if (x > 0) {\n              xLabel = this.#labels[xOffset];\n            };\n            let yLabel = 0;\n            if (y > 0) {\n              yLabel = this.#labels[yOffset];\n            };\n            let zLabel = 0;\n            if (z > 0) {\n              zLabel = this.#labels[zOffset];\n            };\n\n            // No neighbors with matching values\n            if (\n              xValue !== thisValue &&\n              yValue !== thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#labels[thisOffset] = thisOffset; // Guaranteed unique label.\n\n            // One neighbor with matching values\n            } else if (\n              xValue === thisValue &&\n              yValue !== thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#labels[thisOffset] = this.#find(xLabel);\n            } else if (\n              xValue !== thisValue &&\n              yValue === thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#labels[thisOffset] = this.#find(yLabel);\n            } else if (\n              xValue !== thisValue &&\n              yValue !== thisValue &&\n              zValue === thisValue\n            ) {\n              this.#labels[thisOffset] = this.#find(zLabel);\n\n            // Two neighbor with matching values\n            } else if (\n              xValue !== thisValue &&\n              yValue === thisValue &&\n              zValue === thisValue\n            ) {\n              this.#union(yLabel, zLabel);\n              this.#labels[thisOffset] = this.#find(yLabel);\n            } else if (\n              xValue === thisValue &&\n              yValue !== thisValue &&\n              zValue === thisValue\n            ) {\n              this.#union(xLabel, zLabel);\n              this.#labels[thisOffset] = this.#find(xLabel);\n            } else if (\n              xValue === thisValue &&\n              yValue === thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#union(xLabel, yLabel);\n              this.#labels[thisOffset] = this.#find(xLabel);\n\n            // All neighbors with matching values\n            } else if (\n              xValue === thisValue &&\n              yValue === thisValue &&\n              zValue === thisValue\n            ) {\n              this.#union(xLabel, yLabel);\n              this.#union(xLabel, zLabel);\n              this.#labels[thisOffset] = this.#find(xLabel);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert an offset in memory to an index.\n   *\n   * @param {number} offset The offset to convert.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @returns {number[]} The index.\n   */\n  #offsetToIndex(offset, unitVectors) {\n    const values = new Array(unitVectors.length);\n    let off = offset;\n    let dimSize = 0;\n    for (let i = unitVectors.length - 1; i > 0; --i) {\n      dimSize = unitVectors[i];\n      values[i] = Math.floor(off / dimSize);\n      off = off - values[i] * dimSize;\n    }\n    values[0] = off;\n    return values;\n  }\n\n  /**\n   * Quantify labels: count items and calculate centroid.\n   *\n   * @param {TypedArray} buffer The image buffer to regenerate the labels for.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   *\n   * @returns {object[]} The list of quantified labels.\n   */\n  #quantifyLabels(\n    buffer,\n    unitVectors,\n  ) {\n    const detailledInfos = {};\n\n    // Count the number of voxels per unique label,\n    // this has to be done as a second pass.\n    for (let o = 0; o < this.#labels.length; o++) {\n      const labelValue = this.#find(this.#labels[o]);\n\n      if (labelValue >= 0) {\n        const index = this.#offsetToIndex(o, unitVectors);\n        const info = detailledInfos[labelValue];\n        if (typeof info === 'undefined') {\n          detailledInfos[labelValue] = {\n            id: buffer[o],\n            sum: index,\n            count: 1\n          };\n        } else {\n          info.sum[0] += index[0];\n          info.sum[1] += index[1];\n          info.sum[2] += index[2];\n          info.count++;\n        }\n      }\n    }\n\n    const labelsInfo =\n      Object.values(detailledInfos).map(\n        (detailledInfo) => {\n          const index = Array(detailledInfo.sum.length).fill(0);\n          for (let d = 0; d < detailledInfo.sum.length; d++) {\n            index[d] = detailledInfo.sum[d] / detailledInfo.count;\n          }\n\n          return {\n            id: detailledInfo.id,\n            centroidIndex: index,\n            count: detailledInfo.count\n          };\n        }\n      );\n\n    return labelsInfo;\n  }\n\n  /**\n   * Run the filter.\n   *\n   * @param {object} data The input data.\n   * @returns {object[]} The list of quantified labels.\n   */\n  run(data) {\n    const imageBuffer = data.imageBuffer;\n    const unitVectors = data.unitVectors;\n    const sizes = data.sizes;\n    const totalSize = data.totalSize;\n\n    // generate labels\n    this.#regenerateLabels(\n      imageBuffer,\n      unitVectors,\n      sizes,\n      totalSize\n    );\n\n    // quantify labels\n    const labelsInfo = this.#quantifyLabels(\n      imageBuffer,\n      unitVectors,\n    );\n\n    return labelsInfo;\n  }\n} // class labelingFilter\n","/**\n * Labeling filter worker.\n */\n\nimport {LabelingFilter} from './labelingFilter.js';\n\nself.addEventListener('message', function (event) {\n\n  const filter = new LabelingFilter();\n  self.postMessage({\n    labels: filter.run(event.data)\n  });\n\n}, false);\n"],"names":["LabelingFilter","label","currentLabel","this","updateLabel","newLabel","label1","label2","buffer","unitVectors","sizes","totalSize","Int32Array","x","y","z","thisOffset","thisValue","xOffset","yOffset","zOffset","xValue","yValue","zValue","xLabel","yLabel","zLabel","offset","values","Array","length","off","dimSize","i","Math","floor","detailledInfos","o","labelValue","index","info","id","sum","count","Object","map","detailledInfo","fill","d","centroidIndex","run","data","imageBuffer","self","addEventListener","event","filter","postMessage","labels"],"sourceRoot":""}