<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>dwv Source: src/dicom/dicomWriter.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.yeti.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">dwv</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="dwv.html">dwv</a></li><li><a href="dwv.browser.html">dwv.browser</a></li><li><a href="dwv.dicom.html">dwv.dicom</a></li><li><a href="dwv.gui.html">dwv.gui</a></li><li><a href="dwv.gui.base.html">dwv.gui.base</a></li><li><a href="dwv.gui.filter.html">dwv.gui.filter</a></li><li><a href="dwv.gui.filter.base.html">dwv.gui.filter.base</a></li><li><a href="dwv.html.html">dwv.html</a></li><li><a href="dwv.image.html">dwv.image</a></li><li><a href="dwv.image.filter.html">dwv.image.filter</a></li><li><a href="dwv.image.lut.html">dwv.image.lut</a></li><li><a href="dwv.io.html">dwv.io</a></li><li><a href="dwv.math.html">dwv.math</a></li><li><a href="dwv.tests.html">dwv.tests</a></li><li><a href="dwv.tool.html">dwv.tool</a></li><li><a href="dwv.tool.filter_.html">dwv.tool.filter</a></li><li><a href="dwv.utils.html">dwv.utils</a></li><li><a href="dwv.utils.base.html">dwv.utils.base</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-tests_dicom.html">tests/dicom</a></li><li><a href="module-tests_html.html">tests/html</a></li><li><a href="module-tests_image.html">tests/image</a></li><li><a href="module-tests_math.html">tests/math</a></li><li><a href="module-tests_utils.html">tests/utils</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="dwv.App.html">dwv.App</a></li><li><a href="dwv.dicom.DataReader.html">dwv.dicom.DataReader</a></li><li><a href="dwv.dicom.DataWriter.html">dwv.dicom.DataWriter</a></li><li><a href="dwv.dicom.DicomElementsWrapper.html">dwv.dicom.DicomElementsWrapper</a></li><li><a href="dwv.dicom.DicomParser.html">dwv.dicom.DicomParser</a></li><li><a href="dwv.dicom.DicomWriter.html">dwv.dicom.DicomWriter</a></li><li><a href="dwv.gui.base.ColourTool.html">dwv.gui.base.ColourTool</a></li><li><a href="dwv.gui.base.DicomTags.html">dwv.gui.base.DicomTags</a></li><li><a href="dwv.gui.base.Draw.html">dwv.gui.base.Draw</a></li><li><a href="dwv.gui.base.DrawList.html">dwv.gui.base.DrawList</a></li><li><a href="dwv.gui.base.FileLoad.html">dwv.gui.base.FileLoad</a></li><li><a href="dwv.gui.base.Filter.html">dwv.gui.base.Filter</a></li><li><a href="dwv.gui.base.Loadbox.html">dwv.gui.base.Loadbox</a></li><li><a href="dwv.gui.base.Scroll.html">dwv.gui.base.Scroll</a></li><li><a href="dwv.gui.base.Sharpen.html">dwv.gui.base.Sharpen</a></li><li><a href="dwv.gui.base.Slider.html">dwv.gui.base.Slider</a></li><li><a href="dwv.gui.base.Sobel.html">dwv.gui.base.Sobel</a></li><li><a href="dwv.gui.base.Threshold.html">dwv.gui.base.Threshold</a></li><li><a href="dwv.gui.base.Toolbox.html">dwv.gui.base.Toolbox</a></li><li><a href="dwv.gui.base.Undo.html">dwv.gui.base.Undo</a></li><li><a href="dwv.gui.base.UrlLoad.html">dwv.gui.base.UrlLoad</a></li><li><a href="dwv.gui.base.WindowLevel.html">dwv.gui.base.WindowLevel</a></li><li><a href="dwv.gui.base.ZoomAndPan.html">dwv.gui.base.ZoomAndPan</a></li><li><a href="dwv.gui.info.MiniColourMap.html">dwv.gui.info.MiniColourMap</a></li><li><a href="dwv.gui.info.Overlay.html">dwv.gui.info.Overlay</a></li><li><a href="dwv.gui.info.Plot.html">dwv.gui.info.Plot</a></li><li><a href="dwv.html.Layer.html">dwv.html.Layer</a></li><li><a href="dwv.html.Style.html">dwv.html.Style</a></li><li><a href="dwv.image.DicomBufferToView.html">dwv.image.DicomBufferToView</a></li><li><a href="dwv.image.filter.Sharpen.html">dwv.image.filter.Sharpen</a></li><li><a href="dwv.image.filter.Sobel.html">dwv.image.filter.Sobel</a></li><li><a href="dwv.image.filter.Threshold.html">dwv.image.filter.Threshold</a></li><li><a href="dwv.image.Geometry.html">dwv.image.Geometry</a></li><li><a href="dwv.image.Image.html">dwv.image.Image</a></li><li><a href="dwv.image.ImageFactory.html">dwv.image.ImageFactory</a></li><li><a href="dwv.image.lut.Rescale.html">dwv.image.lut.Rescale</a></li><li><a href="dwv.image.lut.Window.html">dwv.image.lut.Window</a></li><li><a href="dwv.image.PixelBufferDecoder.html">dwv.image.PixelBufferDecoder</a></li><li><a href="dwv.image.RescaleSlopeAndIntercept.html">dwv.image.RescaleSlopeAndIntercept</a></li><li><a href="dwv.image.Size.html">dwv.image.Size</a></li><li><a href="dwv.image.Spacing.html">dwv.image.Spacing</a></li><li><a href="dwv.image.View.html">dwv.image.View</a></li><li><a href="dwv.image.ViewFactory.html">dwv.image.ViewFactory</a></li><li><a href="dwv.InfoController.html">dwv.InfoController</a></li><li><a href="dwv.io.FilesLoader.html">dwv.io.FilesLoader</a></li><li><a href="dwv.io.MemoryLoader.html">dwv.io.MemoryLoader</a></li><li><a href="dwv.io.UrlsLoader.html">dwv.io.UrlsLoader</a></li><li><a href="dwv.math.BucketQueue.html">dwv.math.BucketQueue</a></li><li><a href="dwv.math.Circle.html">dwv.math.Circle</a></li><li><a href="dwv.math.Ellipse.html">dwv.math.Ellipse</a></li><li><a href="dwv.math.FastPoint2D.html">dwv.math.FastPoint2D</a></li><li><a href="dwv.math.Index3D.html">dwv.math.Index3D</a></li><li><a href="dwv.math.Line.html">dwv.math.Line</a></li><li><a href="dwv.math.Matrix33.html">dwv.math.Matrix33</a></li><li><a href="dwv.math.Path.html">dwv.math.Path</a></li><li><a href="dwv.math.Point2D.html">dwv.math.Point2D</a></li><li><a href="dwv.math.Point3D.html">dwv.math.Point3D</a></li><li><a href="dwv.math.Rectangle.html">dwv.math.Rectangle</a></li><li><a href="dwv.math.ROI.html">dwv.math.ROI</a></li><li><a href="dwv.math.Scissors.html">dwv.math.Scissors</a></li><li><a href="dwv.math.Vector3D.html">dwv.math.Vector3D</a></li><li><a href="dwv.State.html">dwv.State</a></li><li><a href="dwv.tool.ChangeGroupCommand.html">dwv.tool.ChangeGroupCommand</a></li><li><a href="dwv.tool.DeleteGroupCommand.html">dwv.tool.DeleteGroupCommand</a></li><li><a href="dwv.tool.DrawGroupCommand.html">dwv.tool.DrawGroupCommand</a></li><li><a href="dwv.tool.Filter.html">dwv.tool.Filter</a></li><li><a href="dwv.tool.filter.Sharpen.html">dwv.tool.filter.Sharpen</a></li><li><a href="dwv.tool.filter.Sobel.html">dwv.tool.filter.Sobel</a></li><li><a href="dwv.tool.filter.Threshold.html">dwv.tool.filter.Threshold</a></li><li><a href="dwv.tool.Livewire.html">dwv.tool.Livewire</a></li><li><a href="dwv.tool.MoveGroupCommand.html">dwv.tool.MoveGroupCommand</a></li><li><a href="dwv.tool.RunFilterCommand.html">dwv.tool.RunFilterCommand</a></li><li><a href="dwv.tool.Scroll.html">dwv.tool.Scroll</a></li><li><a href="dwv.tool.Toolbox.html">dwv.tool.Toolbox</a></li><li><a href="dwv.tool.UndoStack.html">dwv.tool.UndoStack</a></li><li><a href="dwv.tool.WindowLevel.html">dwv.tool.WindowLevel</a></li><li><a href="dwv.tool.ZoomAndPan.html">dwv.tool.ZoomAndPan</a></li><li><a href="dwv.ToolboxController.html">dwv.ToolboxController</a></li><li><a href="dwv.utils.ListenerHandler.html">dwv.utils.ListenerHandler</a></li><li><a href="dwv.utils.ThreadPool.html">dwv.utils.ThreadPool</a></li><li><a href="dwv.utils.WorkerTask.html">dwv.utils.WorkerTask</a></li><li><a href="dwv.ViewController.html">dwv.ViewController</a></li><li><a href="Worker.html">Worker</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="global.html#mulABC">mulABC</a></li><li><a href="global.html#webdriver">webdriver</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="externals.list.html" class="dropdown-toggle" data-toggle="dropdown">Externals<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="external-FileReader.html">FileReader</a></li><li><a href="external-i18next.html">i18next</a></li><li><a href="external-i18nextBrowserLanguageDetector.html">i18nextBrowserLanguageDetector</a></li><li><a href="external-JpxImage.html">JpxImage</a></li><li><a href="external-Konva.html">Konva</a></li><li><a href="external-MagicWand.html">MagicWand</a></li><li><a href="external-XMLHttpRequest.html">XMLHttpRequest</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: src/dicom/dicomWriter.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">// namespaces
var dwv = dwv || {};
dwv.dicom = dwv.dicom || {};

/**
 * Data writer.
 *
 * Example usage:
 *   var parser = new dwv.dicom.DicomParser();
 *   parser.parse(this.response);
 *
 *   var writer = new dwv.dicom.DicomWriter(parser.getRawDicomElements());
 *   var blob = new Blob([writer.getBuffer()], {type: 'application/dicom'});
 *
 *   var element = document.getElementById("download");
 *   element.href = URL.createObjectURL(blob);
 *   element.download = "anonym.dcm";
 *
 * @constructor
 * @param {Array} buffer The input array buffer.
 */
dwv.dicom.DataWriter = function (buffer)
{
    // private DataView
    var view = new DataView(buffer);
    // endianness flag
    var isLittleEndian = true;

    /**
     * Write Uint8 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeUint8 = function (byteOffset, value) {
        view.setUint8(byteOffset, value);
        return byteOffset + Uint8Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write Int8 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeInt8 = function (byteOffset, value) {
        view.setInt8(byteOffset, value);
        return byteOffset + Int8Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write Uint16 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeUint16 = function (byteOffset, value) {
        view.setUint16(byteOffset, value, isLittleEndian);
        return byteOffset + Uint16Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write Int16 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeInt16 = function (byteOffset, value) {
        view.setInt16(byteOffset, value, isLittleEndian);
        return byteOffset + Int16Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write Uint32 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeUint32 = function (byteOffset, value) {
        view.setUint32(byteOffset, value, isLittleEndian);
        return byteOffset + Uint32Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write Int32 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeInt32 = function (byteOffset, value) {
        view.setInt32(byteOffset, value, isLittleEndian);
        return byteOffset + Int32Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write Float32 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeFloat32 = function (byteOffset, value) {
        view.setFloat32(byteOffset, value, isLittleEndian);
        return byteOffset + Float32Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write Float64 data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} value The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeFloat64 = function (byteOffset, value) {
        view.setFloat64(byteOffset, value, isLittleEndian);
        return byteOffset + Float64Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write string data as hexadecimal.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} str The padded hexadecimal string to write ('0x####').
     * @returns {Number} The new offset position.
     */
    this.writeHex = function (byteOffset, str) {
        // remove first two chars and parse
        var value = parseInt(str.substr(2), 16);
        view.setUint16(byteOffset, value, isLittleEndian);
        return byteOffset + Uint16Array.BYTES_PER_ELEMENT;
    };

    /**
     * Write string data.
     * @param {Number} byteOffset The offset to start writing from.
     * @param {Number} str The data to write.
     * @returns {Number} The new offset position.
     */
    this.writeString = function (byteOffset, str) {
        for ( var i = 0, len = str.length; i &lt; len; ++i ) {
            view.setUint8(byteOffset, str.charCodeAt(i));
            byteOffset += Uint8Array.BYTES_PER_ELEMENT;
        }
        return byteOffset;
    };

};

/**
 * Write Uint8 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeUint8Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeUint8(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write Int8 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeInt8Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeInt8(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write Uint16 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeUint16Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeUint16(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write Int16 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeInt16Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeInt16(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write Uint32 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeUint32Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeUint32(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write Int32 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeInt32Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeInt32(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write Float32 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeFloat32Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeFloat32(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write Float64 array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeFloat64Array = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        byteOffset = this.writeFloat64(byteOffset, array[i]);
    }
    return byteOffset;
};

/**
 * Write string array.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeStringArray = function (byteOffset, array) {
    for ( var i = 0, len = array.length; i &lt; len; ++i ) {
        // separator
        if ( i !== 0 ) {
            byteOffset = this.writeString(byteOffset, "\\");
        }
        // value
        byteOffset = this.writeString(byteOffset, array[i].toString());
    }
    return byteOffset;
};

/**
 * Write a list of items.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} items The list of items to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeDataElementItems = function (byteOffset, items) {
    var item = null;
    for ( var i = 0; i &lt; items.length; ++i ) {
        item = items[i];
        var itemKeys = Object.keys(item);
        if ( itemKeys.length === 0 ) {
            continue;
        }
        // write item
        var itemElement = item.xFFFEE000;
        itemElement.value = [];
        byteOffset = this.writeDataElement(itemElement, byteOffset);
        // write rest
        for ( var m = 0; m &lt; itemKeys.length; ++m ) {
            if ( itemKeys[m] !== "xFFFEE000" &amp;&amp; itemKeys[m] !== "xFFFEE00D") {
                byteOffset = this.writeDataElement(item[itemKeys[m]], byteOffset);
            }
        }
        // item delimitation
        if (itemElement.vl === "u/l") {
            var itemDelimElement = {
                'tag': { group: "0xFFFE",
                    element: "0xE00D",
                    name: "ItemDelimitationItem" },
                'vr': "NONE",
                'vl': 0,
                'value': []
            };
            byteOffset = this.writeDataElement(itemDelimElement, byteOffset);
        }
    }

    // return new offset
    return byteOffset;
};

/**
 * Write data with a specific Value Representation (VR).
 * @param {String} vr The data Value Representation (VR).
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} value The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeDataElementValue = function (vr, byteOffset, value) {
    // first check input type to know how to write
    if (value instanceof Uint8Array) {
        byteOffset = this.writeUint8Array(byteOffset, value);
    } else if (value instanceof Int8Array) {
        byteOffset = this.writeInt8Array(byteOffset, value);
    } else if (value instanceof Uint16Array) {
        byteOffset = this.writeUint16Array(byteOffset, value);
    } else if (value instanceof Int16Array) {
        byteOffset = this.writeInt16Array(byteOffset, value);
    } else if (value instanceof Uint32Array) {
        byteOffset = this.writeUint32Array(byteOffset, value);
    } else if (value instanceof Int32Array) {
        byteOffset = this.writeInt32Array(byteOffset, value);
    } else {
        // switch according to VR if input type is undefined
        if ( vr === "UN" ) {
            byteOffset = this.writeUint8Array(byteOffset, value);
        } else if ( vr === "OB" ) {
            byteOffset = this.writeInt8Array(byteOffset, value);
        } else if ( vr === "OW" ) {
            byteOffset = this.writeInt16Array(byteOffset, value);
        } else if ( vr === "OF" ) {
            byteOffset = this.writeInt32Array(byteOffset, value);
        } else if ( vr === "OD" ) {
            byteOffset = this.writeInt64Array(byteOffset, value);
        } else if ( vr === "US") {
            byteOffset = this.writeUint16Array(byteOffset, value);
        } else if ( vr === "SS") {
            byteOffset = this.writeInt16Array(byteOffset, value);
        } else if ( vr === "UL") {
            byteOffset = this.writeUint32Array(byteOffset, value);
        } else if ( vr === "SL") {
            byteOffset = this.writeInt32Array(byteOffset, value);
        } else if ( vr === "FL") {
            byteOffset = this.writeFloat32Array(byteOffset, value);
        } else if ( vr === "FD") {
            byteOffset = this.writeFloat64Array(byteOffset, value);
        } else if ( vr === "SQ") {
            byteOffset = this.writeDataElementItems(byteOffset, value);
        } else if ( vr === "AT") {
            var hexString = value + '';
            var hexString1 = hexString.substring(1, 5);
            var hexString2 = hexString.substring(6, 10);
            var dec1 = parseInt(hexString1, 16);
            var dec2 = parseInt(hexString2, 16);
            value = new Uint16Array([dec1, dec2]);
            byteOffset = this.writeUint16Array(byteOffset, value);
        } else {
            byteOffset = this.writeStringArray(byteOffset, value);
        }
    }
    // return new offset
    return byteOffset;
};

/**
 * Write a pixel data element.
 * @param {String} vr The data Value Representation (VR).
 * @param {String} vl The data Value Length (VL).
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Array} value The array to write.
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writePixelDataElementValue = function (vr, vl, byteOffset, value) {
    // explicit length
    if (vl !== "u/l") {
        var finalValue = value[0];
        // flatten multi frame
        if (value.length > 1) {
            finalValue = dwv.dicom.flattenArrayOfTypedArrays(value);
        }
        // write
        byteOffset = this.writeDataElementValue(vr, byteOffset, finalValue);
    } else {
        // pixel data as sequence
        var item = {};
        // first item: basic offset table
        item.xFFFEE000 = {
            'tag': { group: "0xFFFE",
                element: "0xE000",
                name: "xFFFEE000" },
            'vr': "UN",
            'vl': 0,
            'value': []
        };
        // data
        for (var i = 0; i &lt; value.length; ++i) {
            item[i] = {
                'tag': { group: "0xFFFE",
                    element: "0xE000",
                    name: "xFFFEE000" },
                'vr': vr,
                'vl': value[i].length,
                'value': value[i]
            };
        }
        // sequence delimitation item
        item.end = {
            'tag': { group: "0xFFFE",
                element: "0xE0DD",
                name: "xFFFEE0DD" },
            'vr': "UN",
            'vl': 0,
            'value': []
        };
        // write
        byteOffset = this.writeDataElementItems(byteOffset, [item]);
    }

    // return new offset
    return byteOffset;
};

/**
 * Write a data element.
 * @param {Object} element The DICOM data element to write.
 * @param {Number} byteOffset The offset to start writing from.
 * @param {Boolean} isImplicit Is the DICOM VR implicit?
 * @returns {Number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeDataElement = function (element, byteOffset, isImplicit) {
    var isTagWithVR = dwv.dicom.isTagWithVR(element.tag.group, element.tag.element);
    var is32bitVLVR = (isImplicit || !isTagWithVR) ? true : dwv.dicom.is32bitVLVR(element.vr);
    // group
    byteOffset = this.writeHex(byteOffset, element.tag.group);
    // element
    byteOffset = this.writeHex(byteOffset, element.tag.element);
    // VR
    if ( isTagWithVR &amp;&amp; !isImplicit ) {
        byteOffset = this.writeString(byteOffset, element.vr);
        // reserved 2 bytes for 32bit VL
        if ( is32bitVLVR ) {
            byteOffset += 2;
        }
    }

    // update vl for sequence or item with implicit length
    var vl = element.vl;
    if ( dwv.dicom.isImplicitLengthSequence(element) ||
        dwv.dicom.isImplicitLengthItem(element) ||
        dwv.dicom.isImplicitLengthPixels(element) ) {
        vl = 0xffffffff;
    }
    // VL
    if ( is32bitVLVR ) {
        byteOffset = this.writeUint32(byteOffset, vl);
    }
    else {
        byteOffset = this.writeUint16(byteOffset, vl);
    }

    // value
    var value = element.value;
    // check value
    if (typeof value === 'undefined') {
        value = [];
    }
    // write
    if (element.tag.name === "x7FE00010") {
        byteOffset = this.writePixelDataElementValue(element.vr, element.vl, byteOffset, value);
    } else {
        byteOffset = this.writeDataElementValue(element.vr, byteOffset, value);
    }

    // sequence delimitation item for sequence with implicit length
    if ( dwv.dicom.isImplicitLengthSequence(element) ) {
        var seqDelimElement = {
            'tag': { group: "0xFFFE",
                element: "0xE0DD",
                name: "SequenceDelimitationItem" },
            'vr': "NONE",
            'vl': 0,
            'value': []
        };
        byteOffset = this.writeDataElement(seqDelimElement, byteOffset);
    }

    // return new offset
    return byteOffset;
};


/**
 * Tell if a given syntax is supported for writing.
 * @param {String} syntax The transfer syntax to test.
 * @return {Boolean} True if a supported syntax.
 */
dwv.dicom.isWriteSupportedTransferSyntax = function (syntax) {
    return syntax === "1.2.840.10008.1.2" || // Implicit VR - Little Endian
        syntax === "1.2.840.10008.1.2.1"; // Explicit VR - Little Endian
};

/**
 * Is this element an implicit length sequence?
 * @param {Object} element The element to check.
 * @returns {Boolean} True if it is.
 */
dwv.dicom.isImplicitLengthSequence = function (element) {
    // sequence with no length
    return (element.vr === "SQ") &amp;&amp;
        (element.vl === "u/l");
};

/**
 * Is this element an implicit length item?
 * @param {Object} element The element to check.
 * @returns {Boolean} True if it is.
 */
dwv.dicom.isImplicitLengthItem = function (element) {
    // item with no length
    return (element.tag.name === "xFFFEE000") &amp;&amp;
        (element.vl === "u/l");
};

/**
 * Is this element an implicit length pixel data?
 * @param {Object} element The element to check.
 * @returns {Boolean} True if it is.
 */
dwv.dicom.isImplicitLengthPixels = function (element) {
    // pixel data with no length
    return (element.tag.name === "x7FE00010") &amp;&amp;
        (element.vl === "u/l");
};

/**
 * Helper method to flatten an array of typed arrays to 2D typed array
 * @param {Array} array of typed arrays
 * @returns {Object} a typed array containing all values
 */
dwv.dicom.flattenArrayOfTypedArrays = function(initialArray) {
    var initialArrayLength = initialArray.length;
    var arrayLength = initialArray[0].length;
    var flattenendArrayLength = initialArrayLength * arrayLength;

    var flattenedArray = new initialArray[0].constructor(flattenendArrayLength);

    for (var i = 0; i &lt; initialArrayLength; i++) {
        var indexFlattenedArray = i * arrayLength;
        flattenedArray.set(initialArray[i], indexFlattenedArray);
    }
    return flattenedArray;
};

/**
 * DICOM writer.
 * @constructor
 */
dwv.dicom.DicomWriter = function () {

    // possible tag actions
    var actions = {
        'copy': function (item) { return item; },
        'remove': function () { return null; },
        'clear': function (item) {
            item.value[0] = "";
            item.vl = 0;
            item.endOffset = item.startOffset;
            return item;
        },
        'replace': function (item, value) {
            item.value[0] = value;
            item.vl = value.length;
            item.endOffset = item.startOffset + value.length;
            return item;
        }
    };

    // default rules: just copy
    var defaultRules = {
        'default': {action: 'copy', value: null }
    };

    /**
     * Public (modifiable) rules.
     * Set of objects as:
     *   name : { action: 'actionName', value: 'optionalValue }
     * The names are either 'default', tagName or groupName.
     * Each DICOM element will be checked to see if a rule is applicable.
     * First checked by tagName and then by groupName,
     * if nothing is found the default rule is applied.
     */
    this.rules = defaultRules;

    /**
     * Example anonymisation rules.
     */
    this.anonymisationRules = {
        'default': {action: 'remove', value: null },
        'PatientName': {action: 'replace', value: 'Anonymized'}, // tag
        'Meta Element' : {action: 'copy', value: null }, // group 'x0002'
        'Acquisition' : {action: 'copy', value: null }, // group 'x0018'
        'Image Presentation' : {action: 'copy', value: null }, // group 'x0028'
        'Procedure' : {action: 'copy', value: null }, // group 'x0040'
        'Pixel Data' : {action: 'copy', value: null } // group 'x7fe0'
    };

    /**
     * Get the element to write according to the class rules.
     * Priority order: tagName, groupName, default.
     * @param {Object} element The element to check
     * @return {Object} The element to write, can be null.
     */
    this.getElementToWrite = function (element) {
        // get group and tag string name
        var tagName = null;
        var dict = dwv.dicom.dictionary;
        var group = element.tag.group;
        var groupName = dwv.dicom.TagGroups[group.substr(1)]; // remove first 0

        if ( typeof dict[group] !== 'undefined' &amp;&amp; typeof dict[group][element.tag.element] !== 'undefined') {
            tagName = dict[group][element.tag.element][2];
        }
        // apply rules:
        var rule;
        // 1. tag itself
        if (typeof this.rules[element.tag.name] !== 'undefined') {
        	rule = this.rules[element.tag.name];
        }
        // 2. tag name
        else if ( tagName !== null &amp;&amp; typeof this.rules[tagName] !== 'undefined' ) {
            rule = this.rules[tagName];
        }
        // 3. group name
        else if ( typeof this.rules[groupName] !== 'undefined' ) {
            rule = this.rules[groupName];
        }
        // 4. default
        else {
            rule = this.rules['default'];
        }
        // apply action on element and return
        return actions[rule.action](element, rule.value);
    };
};

/**
 * Get the ArrayBuffer corresponding to input DICOM elements.
 * @param {Array} dicomElements The wrapped elements to write.
 * @returns {ArrayBuffer} The elements as a buffer.
 */
dwv.dicom.DicomWriter.prototype.getBuffer = function (dicomElements) {
    // array keys
    var keys = Object.keys(dicomElements);

    // transfer syntax
    var syntax = dwv.dicom.cleanString(dicomElements.x00020010.value[0]);
    var isImplicit = dwv.dicom.isImplicitTransferSyntax(syntax);

    // check support
    if (!dwv.dicom.isWriteSupportedTransferSyntax(syntax)) {
        throw new Error("Unsupported DICOM transfer syntax: '"+syntax+
            "' ("+dwv.dicom.getTransferSyntaxName(syntax)+")");
    }

    // calculate buffer size and split elements (meta and non meta)
    var totalSize = 128 + 4; // DICM
    var localSize = 0;
    var metaElements = [];
    var rawElements = [];
    var element;
    var groupName;
    var metaLength = 0;
    for ( var i = 0, leni = keys.length; i &lt; leni; ++i ) {
        element = this.getElementToWrite(dicomElements[keys[i]]);
        if ( element !== null ) {
            localSize = 0;
            // tag group name
            groupName = dwv.dicom.TagGroups[element.tag.group.substr(1)]; // remove first 0

            // prefix
            if ( groupName === 'Meta Element' ) {
                localSize += dwv.dicom.getDataElementPrefixByteSize(element.vr, false);
            } else {
                localSize += dwv.dicom.getDataElementPrefixByteSize(element.vr, isImplicit);
            }

            // value
            var realVl = element.endOffset - element.startOffset;
            localSize += parseInt(realVl, 10);

            // add size of sequence delimitation item
            if ( dwv.dicom.isImplicitLengthSequence(element) ) {
                localSize += dwv.dicom.getDataElementPrefixByteSize("NONE", isImplicit);
            }

            // sort elements
            if ( groupName === 'Meta Element' ) {
                metaElements.push(element);
                metaLength += localSize;
            }
            else {
                rawElements.push(element);
            }

            // add to total size
            totalSize += localSize;
        }
    }

    // create the FileMetaInformationGroupLength element
    var fmigl = dwv.dicom.getDicomElement("FileMetaInformationGroupLength");
    var fmiglSize = dwv.dicom.getDataElementPrefixByteSize(fmigl.vr, isImplicit);
    fmiglSize += dwv.dicom.setElementValue(fmigl, metaLength, false);

    // add its size to the total one
    totalSize += fmiglSize;

    // create buffer
    var buffer = new ArrayBuffer(totalSize);
    var writer = new dwv.dicom.DataWriter(buffer);
    var offset = 128;
    // DICM
    offset = writer.writeString(offset, "DICM");
    // FileMetaInformationGroupLength
    offset = writer.writeDataElement(fmigl, offset, false);
    // write meta
    for ( var j = 0, lenj = metaElements.length; j &lt; lenj; ++j ) {
        offset = writer.writeDataElement(metaElements[j], offset, false);
    }
    // write non meta
    for ( var k = 0, lenk = rawElements.length; k &lt; lenk; ++k ) {
        offset = writer.writeDataElement(rawElements[k], offset, isImplicit);
    }

    // return
    return buffer;
};

/**
 * Get a DICOM element from its tag name (value set separatly).
 * @param {String} tagName The string tag name.
 * @return {Object} The DICOM element.
 */
dwv.dicom.getDicomElement = function (tagName)
{
   var tagGE = dwv.dicom.getGroupElementFromName(tagName);
   var dict = dwv.dicom.dictionary;
   // return element definition
   return {
     'tag': { 'group': tagGE.group, 'element': tagGE.element },
     'vr': dict[tagGE.group][tagGE.element][0],
     'vl': dict[tagGE.group][tagGE.element][1]
   };
};

/**
 * Set a DICOM element value according to its VR (Value Representation).
 * @param {Object} element The DICOM element to set the value.
 * @param {Object} value The value to set.
 * @param {Boolean} isImplicit Does the data use implicit VR?
 * @return {Number} The total element size.
 */
dwv.dicom.setElementValue = function (element, value, isImplicit) {
    // byte size of the element
    var size = 0;
    // special sequence case
    if ( element.vr === "SQ") {

        // set the value
        element.value = value;

        if ( value !== null &amp;&amp; value !== 0 ) {
            var sqItems = [];
            var name;

            // explicit or implicit length
            var explicitLength = true;
            if ( typeof value.explicitLength !== "undefined" ) {
                explicitLength = value.explicitLength;
                delete value.explicitLength;
            }

            // items
            var itemData;
            var itemKeys = Object.keys(value);
            for ( var i = 0, leni = itemKeys.length; i &lt; leni; ++i )
            {
                var itemElements = {};
                var subSize = 0;
                itemData = value[itemKeys[i]];

                // elements
                var subElement;
                var elemKeys = Object.keys(itemData);
                for ( var j = 0, lenj = elemKeys.length; j &lt; lenj; ++j )
                {
                    subElement = dwv.dicom.getDicomElement(elemKeys[j]);
                    subSize += dwv.dicom.setElementValue(subElement, itemData[elemKeys[j]]);

                    // add sequence delimitation size for sub sequences
                    if (dwv.dicom.isImplicitLengthSequence(subElement)) {
                        subSize += dwv.dicom.getDataElementPrefixByteSize("NONE", isImplicit);
                    }

                    name = dwv.dicom.getGroupElementKey(subElement.tag.group, subElement.tag.element);
                    itemElements[name] = subElement;
                }

                // item (after elements to get the size)
                var itemElement = {
                         'tag': { 'group': "0xFFFE", 'element': "0xE000" },
                         'vr': "NONE",
                         'vl': (explicitLength ? subSize : 0xffffffff),
                         'value': []
                     };
                name = dwv.dicom.getGroupElementKey(itemElement.tag.group, itemElement.tag.element);
                itemElements[name] = itemElement;
                subSize += dwv.dicom.getDataElementPrefixByteSize("NONE", isImplicit);

                // item delimitation
                if (!explicitLength) {
                    var itemDelimElement = {
                            'tag': { 'group': "0xFFFE", 'element': "0xE00D" },
                            'vr': "NONE",
                            'vl': 0,
                            'value': []
                        };
                    name = dwv.dicom.getGroupElementKey(itemDelimElement.tag.group, itemDelimElement.tag.element);
                    itemElements[name] = itemDelimElement;
                    subSize += dwv.dicom.getDataElementPrefixByteSize("NONE", isImplicit);
                }

                size += subSize;
                sqItems.push(itemElements);
            }

            element.value = sqItems;
        }

        element.vl = size;
    }
    else {
        // set the value and calculate size
        size = 0;
        if (value instanceof Array) {
            element.value = value;
            for (var k = 0; k &lt; value.length; ++k) {
                // spearator
                if (k !== 0) {
                    size += 1;
                }
                // value
                size += value[k].toString().length;
            }
        }
        else {
            element.value = [value];
            if (typeof value !== "undefined" &amp;&amp; typeof value.length !== "undefined") {
                size = value.length;
            }
            else {
                // numbers
                size = 1;
            }
        }

        // convert size to bytes
        if ( element.vr === "US" || element.vr === "OW") {
            size *= Uint16Array.BYTES_PER_ELEMENT;
        }
        else if ( element.vr === "SS") {
            size *= Int16Array.BYTES_PER_ELEMENT;
        }
        else if ( element.vr === "UL") {
            size *= Uint32Array.BYTES_PER_ELEMENT;
        }
        else if ( element.vr === "SL") {
            size *= Int32Array.BYTES_PER_ELEMENT;
        }
        else if ( element.vr === "FL") {
            size *= Float32Array.BYTES_PER_ELEMENT;
        }
        else if ( element.vr === "FD") {
            size *= Float64Array.BYTES_PER_ELEMENT;
        }
        else {
            size *= Uint8Array.BYTES_PER_ELEMENT;
        }
        element.vl = size;
    }

    // return the size of that data
    return size;
};

/**
 * Get the DICOM element from a DICOM tags object.
 * @param {Object} tags The DICOM tags object.
 * @return {Object} The DICOM elements and the end offset.
 */
dwv.dicom.getElementsFromJSONTags = function (tags) {
    // transfer syntax
    var isImplicit = dwv.dicom.isImplicitTransferSyntax(tags.TransferSyntaxUID);
    // convert JSON to DICOM element object
    var keys = Object.keys(tags);
    var dicomElements = {};
    var dicomElement;
    var name;
    var offset = 128 + 4; // preamble
    var size;
    for ( var k = 0, len = keys.length; k &lt; len; ++k )
    {
        // get the DICOM element definition from its name
        dicomElement = dwv.dicom.getDicomElement(keys[k]);
        // set its value
        size = dwv.dicom.setElementValue(dicomElement, tags[keys[k]], isImplicit);
        // set offsets
        offset += dwv.dicom.getDataElementPrefixByteSize(dicomElement.vr, isImplicit);
        dicomElement.startOffset = offset;
        offset += size;
        dicomElement.endOffset = offset;
        // create the tag group/element key
        name = dwv.dicom.getGroupElementKey(dicomElement.tag.group, dicomElement.tag.element);
        // store
        dicomElements[name] = dicomElement;
    }
    // return
    return {'elements': dicomElements, 'offset': offset };
};

/**
 * Get the DICOM pixel data from a DICOM tags object.
 * @param {Object} tags The DICOM tags object.
 * @param {Object} startOffset The start offset of the pixel data.
 * @return {Object} The DICOM pixel data element.
 */
dwv.dicom.generatePixelDataFromJSONTags = function (tags, startOffset) {

    // check tags
    if ( typeof tags.TransferSyntaxUID === "undefined" ) {
        throw new Error("Missing transfer syntax for pixel generation.");
    } else if ( typeof tags.Rows === "undefined" ) {
        throw new Error("Missing number of rows for pixel generation.");
    } else if ( typeof tags.Columns === "undefined" ) {
        throw new Error("Missing number of columns for pixel generation.");
    } else if ( typeof tags.BitsAllocated === "undefined" ) {
        throw new Error("Missing BitsAllocated for pixel generation.");
    } else if ( typeof tags.PixelRepresentation === "undefined" ) {
        throw new Error("Missing PixelRepresentation for pixel generation.");
    }

    // extract info from tags
    var isImplicit = dwv.dicom.isImplicitTransferSyntax(tags.TransferSyntaxUID);
    var numberOfRows = tags.Rows;
    var numberOfColumns = tags.Columns;
    var bitsAllocated = tags.BitsAllocated;
    var pixelRepresentation = tags.PixelRepresentation;

    // create pixel array
    var pixels = dwv.dicom.getTypedArray(bitsAllocated, pixelRepresentation,
        numberOfRows * numberOfColumns);
    //pixels.fill(100); // not supported on phantom?
    for ( var k = 0; k &lt; numberOfRows*numberOfColumns; ++k ) {
        pixels[k] = 100;
    }

    // pixels: small gradient square
    var widthI = numberOfColumns * 0.5;
    var widthJ = numberOfRows * 0.5;
    var maxNoBounds =  (numberOfColumns/2 + widthI/2) * (numberOfRows/2 + widthJ/2);
    var max = 100;
    for ( var j = 0; j &lt; numberOfRows; ++j ) {
        var jc = Math.abs( j - (numberOfRows/2) );
        for ( var i = 0; i &lt; numberOfColumns; ++i ) {
            var ic = Math.abs( i - (numberOfColumns/2) );
            if ( jc &lt; widthJ/2 &amp;&amp; ic &lt; widthI/2) {
                pixels[numberOfColumns*j + i] += (i * j) * max / maxNoBounds;
            }
        }
    }

    // create and return the DICOM element
    var vr = "OW";
    var pixVL = dwv.dicom.getDataElementPrefixByteSize(vr, isImplicit) +
       (pixels.BYTES_PER_ELEMENT * numberOfRows * numberOfColumns);
    return {
            'tag': { 'group': "0x7FE0", 'element': "0x0010" },
            'vr': vr,
            'vl': pixVL,
            'value': pixels,
            'startOffset': startOffset,
            'endOffset': startOffset + pixVL
        };
};
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
		on Tuesday, October 10th 2017
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
