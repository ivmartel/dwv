{"version":3,"file":"resampling.worker.min.js","mappings":"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","sources":["webpack://dwv/./src/math/vector.js","webpack://dwv/./src/math/point.js","webpack://dwv/./src/math/index.js","webpack://dwv/./src/utils/logger.js","webpack://dwv/./src/math/matrix.js","webpack://dwv/./src/image/resamplingFilter.js","webpack://dwv/./src/image/resampling.worker.js"],"sourcesContent":["/**\n * Immutable 3D vector.\n */\nexport class Vector3D {\n\n  /**\n   * X coordinate.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y coordinate.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * Z coordinate.\n   *\n   * @type {number}\n   */\n  #z;\n\n  /**\n   * @param {number} x The X component of the vector.\n   * @param {number} y The Y component of the vector.\n   * @param {number} z The Z component of the vector.\n   */\n  constructor(x, y, z) {\n    this.#x = x;\n    this.#y = y;\n    this.#z = z;\n  }\n\n  /**\n   * Get the X component of the vector.\n   *\n   * @returns {number} The X component of the vector.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y component of the vector.\n   *\n   * @returns {number} The Y component of the vector.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the Z component of the vector.\n   *\n   * @returns {number} The Z component of the vector.\n   */\n  getZ() {\n    return this.#z;\n  }\n\n  /**\n   * Check for Vector3D equality.\n   *\n   * @param {Vector3D} rhs The other vector to compare to.\n   * @returns {boolean} True if both vectors are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY() &&\n      this.#z === rhs.getZ();\n  }\n\n  /**\n   * Get a string representation of the Vector3D.\n   *\n   * @returns {string} The vector as a string.\n   */\n  toString() {\n    return '(' + this.#x +\n      ', ' + this.#y +\n      ', ' + this.#z + ')';\n  }\n\n  /**\n   * Get the norm of the vector.\n   *\n   * @returns {number} The norm.\n   */\n  norm() {\n    return Math.sqrt(\n      (this.#x * this.#x) +\n      (this.#y * this.#y) +\n      (this.#z * this.#z)\n    );\n  }\n\n  /**\n   * Get the cross product with another Vector3D, ie the\n   * vector that is perpendicular to both a and b.\n   * If both vectors are parallel, the cross product is a zero vector.\n   *\n   * Ref: {@link https://en.wikipedia.org/wiki/Cross_product}.\n   *\n   * @param {Vector3D} vector3D The input vector.\n   * @returns {Vector3D} The result vector.\n   */\n  crossProduct(vector3D) {\n    return new Vector3D(\n      (this.#y * vector3D.getZ()) - (vector3D.getY() * this.#z),\n      (this.#z * vector3D.getX()) - (vector3D.getZ() * this.#x),\n      (this.#x * vector3D.getY()) - (vector3D.getX() * this.#y));\n  }\n\n  /**\n   * Get the dot product with another Vector3D.\n   *\n   * Ref: {@link https://en.wikipedia.org/wiki/Dot_product}.\n   *\n   * @param {Vector3D} vector3D The input vector.\n   * @returns {number} The dot product.\n   */\n  dotProduct(vector3D) {\n    return (this.#x * vector3D.getX()) +\n      (this.#y * vector3D.getY()) +\n      (this.#z * vector3D.getZ());\n  }\n\n  /**\n   * Is this vector codirectional to an input one.\n   *\n   * @param {Vector3D} vector3D The vector to test.\n   * @returns {boolean} True if codirectional, false is opposite.\n   */\n  isCodirectional(vector3D) {\n    // a.dot(b) = ||a|| * ||b|| * cos(theta)\n    // (https://en.wikipedia.org/wiki/Dot_product#Geometric_definition)\n    // -> the sign of the dot product depends on the cosinus of\n    //    the angle between the vectors\n    //   -> >0 => vectors are codirectional\n    //   -> <0 => vectors are opposite\n    return this.dotProduct(vector3D) > 0;\n  }\n\n} // Vector3D class","import {isSimilar} from './matrix.js';\nimport {Vector3D} from './vector.js';\n\n/**\n * Immutable 2D point.\n */\nexport class Point2D {\n\n  /**\n   * X position.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y position.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * @param {number} x The X coordinate for the point.\n   * @param {number} y The Y coordinate for the point.\n   */\n  constructor(x, y) {\n    this.#x = x;\n    this.#y = y;\n  }\n\n  /**\n   * Get the X position of the point.\n   *\n   * @returns {number} The X position of the point.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y position of the point.\n   *\n   * @returns {number} The Y position of the point.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return [this.#x, this.#y];\n  }\n\n  /**\n   * Get the centroid of the point, ie itself.\n   *\n   * @returns {Point2D} The centroid point.\n   */\n  getCentroid() {\n    return this;\n  }\n\n  /**\n   * Check for Point2D equality.\n   *\n   * @param {Point2D} rhs The other point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      typeof rhs !== 'undefined' &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY();\n  }\n\n  /**\n   * Get a string representation of the Point2D.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#x + ', ' + this.#y + ')';\n  }\n\n  /**\n   * Get the distance to another Point2D.\n   *\n   * @param {Point2D} point2D The input point.\n   * @returns {number} Ths distance to the input point.\n   */\n  getDistance(point2D) {\n    const dx = this.#x - point2D.getX();\n    const dy = this.#y - point2D.getY();\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n} // Point2D class\n\n/**\n * Immutable 3D point.\n */\nexport class Point3D {\n\n  /**\n   * X position.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y position.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * Z position.\n   *\n   * @type {number}\n   */\n  #z;\n\n  /**\n   * @param {number} x The X coordinate for the point.\n   * @param {number} y The Y coordinate for the point.\n   * @param {number} z The Z coordinate for the point.\n   */\n  constructor(x, y, z) {\n    this.#x = x;\n    this.#y = y;\n    this.#z = z;\n  }\n\n  /**\n   * Get the X position of the point.\n   *\n   * @returns {number} The X position of the point.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y position of the point.\n   *\n   * @returns {number} The Y position of the point.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the Z position of the point.\n   *\n   * @returns {number} The Z position of the point.\n   */\n  getZ() {\n    return this.#z;\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return [this.#x, this.#y, this.#z];\n  }\n\n  /**\n   * Check for Point3D equality.\n   *\n   * @param {Point3D} rhs The other point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY() &&\n      this.#z === rhs.getZ();\n  }\n\n  /**\n   * Check for Point3D similarity.\n   *\n   * @param {Point3D} rhs The other point to compare to.\n   * @param {number} [tol] Optional number comparison tolerance,\n   *   defaults to Number.EPSILON.\n   * @returns {boolean} True if both points are similar.\n   */\n  isSimilar(rhs, tol) {\n    return rhs !== null &&\n      isSimilar(this.#x, rhs.getX(), tol) &&\n      isSimilar(this.#y, rhs.getY(), tol) &&\n      isSimilar(this.#z, rhs.getZ(), tol);\n  }\n\n  /**\n   * Get a string representation of the Point3D.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#x +\n      ', ' + this.#y +\n      ', ' + this.#z + ')';\n  }\n\n  /**\n   * Get the distance to another Point3D.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {number} Ths distance to the input point.\n   */\n  getDistance(point3D) {\n    return Math.sqrt(this.#getSquaredDistance(point3D));\n  }\n\n  /**\n   * Get the square of the distance between this and\n   * an input point. Used for sorting.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {number} The square of the distance.\n   */\n  #getSquaredDistance(point3D) {\n    const dx = this.#x - point3D.getX();\n    const dy = this.#y - point3D.getY();\n    const dz = this.#z - point3D.getZ();\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  /**\n   * Get the closest point to this in a Point3D list.\n   *\n   * @param {Point3D[]} pointList The list to check.\n   * @returns {number} The index of the closest point in the input list.\n   */\n  getClosest(pointList) {\n    let minIndex = 0;\n    // the order between squared distances and distances is the same\n    let minDist = this.#getSquaredDistance(pointList[minIndex]);\n    for (let i = 0; i < pointList.length; ++i) {\n      const dist = this.#getSquaredDistance(pointList[i]);\n      if (dist < minDist) {\n        minIndex = i;\n        minDist = dist;\n      }\n    }\n    return minIndex;\n  }\n\n  /**\n   * Get the difference to another Point3D.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {Vector3D} The 3D vector from the input point to this one.\n   */\n  minus(point3D) {\n    return new Vector3D(\n      (this.#x - point3D.getX()),\n      (this.#y - point3D.getY()),\n      (this.#z - point3D.getZ()));\n  }\n\n} // Point3D class\n\n/**\n * Get an array find callback for an equal input point.\n *\n * @param {Point3D} point The point to compare to.\n * @returns {Function} A function that compares, using `equals`,\n *   its input point to the one given as input to this function.\n */\nexport function getEqualPoint3DFunction(point) {\n  return function (element) {\n    return element.equals(point);\n  };\n}\n\n/**\n * Immutable point.\n * Warning: the input array is NOT cloned, modifying it will\n *  modify the point values.\n */\nexport class Point {\n\n  /**\n   * Point values.\n   *\n   * @type {number[]}\n   */\n  #values;\n\n  /**\n   * @param {number[]} values The point values.\n   */\n  constructor(values) {\n    if (!values || typeof values === 'undefined') {\n      throw new Error('Cannot create point with no values.');\n    }\n    if (values.length === 0) {\n      throw new Error('Cannot create point with empty values.');\n    }\n    const valueCheck = function (val) {\n      return !isNaN(val);\n    };\n    if (!values.every(valueCheck)) {\n      throw new Error('Cannot create point with non number values.');\n    }\n    this.#values = values;\n  }\n\n  /**\n   * Get the point value at the given array index.\n   *\n   * @param {number} i The index to get.\n   * @returns {number} The value.\n   */\n  get(i) {\n    return this.#values[i];\n  }\n\n  /**\n   * Get the length of the point.\n   *\n   * @returns {number} The length.\n   */\n  length() {\n    return this.#values.length;\n  }\n\n  /**\n   * Get a string representation of the point.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#values.toString() + ')';\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return this.#values.slice();\n  }\n\n  /**\n   * Check if the input point can be compared to this one.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {boolean} True if both points are comparable.\n   */\n  canCompare(rhs) {\n    // check input\n    if (!rhs) {\n      return false;\n    }\n    // check length\n    if (this.length() !== rhs.length()) {\n      return false;\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Check for Point equality.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return false;\n    }\n    // check values\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        return false;\n      }\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Compare points and return different dimensions.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {number[]} The list of different dimensions.\n   */\n  compare(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    // check values\n    const diffDims = [];\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        diffDims.push(i);\n      }\n    }\n    return diffDims;\n  }\n\n  /**\n   * Get the 3D part of this point.\n   *\n   * @returns {Point3D} The Point3D.\n   */\n  get3D() {\n    return new Point3D(this.get(0), this.get(1), this.get(2));\n  }\n\n  /**\n   * Add another point to this one.\n   *\n   * @param {Point} rhs The point to add.\n   * @returns {Point} The point representing the sum of both points.\n   */\n  add(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    const values = [];\n    const values0 = this.getValues();\n    const values1 = rhs.getValues();\n    for (let i = 0; i < values0.length; ++i) {\n      values.push(values0[i] + values1[i]);\n    }\n    return new Point(values);\n  }\n\n  /**\n   * Merge this point with a Point3D to create a new point.\n   *\n   * @param {Point3D} rhs The Point3D to merge with.\n   * @returns {Point} The merge result.\n   */\n  mergeWith3D(rhs) {\n    const values = this.getValues();\n    values[0] = rhs.getX();\n    values[1] = rhs.getY();\n    values[2] = rhs.getZ();\n    return new Point(values);\n  }\n\n} // Point class\n","/**\n * Immutable index.\n * Warning: the input array is NOT cloned, modifying it will\n *  modify the index values.\n */\nexport class Index {\n\n  /**\n   * Index values.\n   *\n   * @type {number[]}\n   */\n  #values;\n\n  /**\n   * @param {number[]} values The index values.\n   */\n  constructor(values) {\n    if (!values || typeof values === 'undefined') {\n      throw new Error('Cannot create index with no values.');\n    }\n    if (values.length === 0) {\n      throw new Error('Cannot create index with empty values.');\n    }\n    const valueCheck = function (val) {\n      return !isNaN(val);\n    };\n    if (!values.every(valueCheck)) {\n      throw new Error('Cannot create index with non number values.');\n    }\n    this.#values = values;\n  }\n\n  /**\n   * Get the index value at the given array index.\n   *\n   * @param {number} i The index to get.\n   * @returns {number|undefined} The value or undefined if not in range.\n   */\n  get(i) {\n    return this.#values[i];\n  }\n\n  /**\n   * Get the length of the index.\n   *\n   * @returns {number} The length.\n   */\n  length() {\n    return this.#values.length;\n  }\n\n  /**\n   * Get a string representation of the Index.\n   *\n   * @returns {string} The Index as a string.\n   */\n  toString() {\n    return '(' + this.#values.toString() + ')';\n  }\n\n  /**\n   * Get the values of this index.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return this.#values.slice();\n  }\n\n  /**\n   * Check if the input index can be compared to this one.\n   *\n   * @param {Index} rhs The index to compare to.\n   * @returns {boolean} True if both indices are comparable.\n   */\n  canCompare(rhs) {\n    // check input\n    if (!rhs) {\n      return false;\n    }\n    // check length\n    if (this.length() !== rhs.length()) {\n      return false;\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Check for Index equality.\n   *\n   * @param {Index} rhs The index to compare to.\n   * @returns {boolean} True if both indices are equal.\n   */\n  equals(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return false;\n    }\n    // check values\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        return false;\n      }\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Compare indices and return different dimensions.\n   *\n   * @param {Index} rhs The index to compare to.\n   * @returns {number[]} The list of different dimensions.\n   */\n  compare(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    // check values\n    const diffDims = [];\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        diffDims.push(i);\n      }\n    }\n    return diffDims;\n  }\n\n  /**\n   * Add another index to this one and return\n   *   the result as a new index.\n   *\n   * @param {Index} rhs The index to add.\n   * @returns {Index} The index representing the sum of both indices.\n   */\n  add(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    // add values\n    const values = [];\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      values.push(this.get(i) + rhs.get(i));\n    }\n    // seems ok!\n    return new Index(values);\n  }\n\n  /**\n   * Add the input value to this index at the given\n   *   dimension number and return the result\n   *   as a new index.\n   *\n   * @param {number} dim The dimension number.\n   * @param {number} value The value to add.\n   * @returns {Index} The result index.\n   */\n  #addToDim(dim, value) {\n    const values = this.#values.slice();\n    if (dim < values.length) {\n      values[dim] += value;\n    } else {\n      console.warn('Cannot add to given dimension: ', dim, values.length);\n    }\n    return new Index(values);\n  }\n\n  /**\n   * Increment this index by 1 at the given dimension\n   *   and return the result as a new index.\n   *\n   * @param {number} dim The dimension number.\n   * @returns {Index} The result index.\n   */\n  next(dim) {\n    return this.#addToDim(dim, 1);\n  }\n\n  /**\n   * Decrement this index by 1 at the given dimension\n   *   and return the result as a new index.\n   *\n   * @param {number} dim The dimension number.\n   * @returns {Index} The result index.\n   */\n  previous(dim) {\n    return this.#addToDim(dim, -1);\n  }\n\n  /**\n   * Get the current index with a new 2D base\n   *   and return the result as a new index.\n   *\n   * @param {number} i The new 0 index.\n   * @param {number} j The new 1 index.\n   * @returns {Index} The new index.\n   */\n  getWithNew2D(i, j) {\n    const values = [i, j];\n    for (let l = 2, lenl = this.length(); l < lenl; ++l) {\n      values.push(this.get(l));\n    }\n    return new Index(values);\n  }\n\n} // Index class\n\n/**\n * Get an index with values set to 0 and the input size.\n *\n * @param {number} size The size of the index.\n * @returns {Index} The zero index.\n */\nexport function getZeroIndex(size) {\n  const values = new Array(size);\n  values.fill(0);\n  return new Index(values);\n}\n","export const logger = {\n  /**\n   * Available log levels.\n   * Note: need to activate verbose level in\n   *   Chrome console to see DEBUG messages.\n   */\n  levels: {\n    TRACE: 0,\n    DEBUG: 1,\n    INFO: 2,\n    WARN: 3,\n    ERROR: 4\n  },\n\n  /**\n   * Logger level: default to WARN.\n   */\n  level: 3,\n\n  /**\n   * Log a trace message.\n   *\n   * @param {string} msg The message to log.\n   */\n  trace: function (msg) {\n    if (this.level <= this.levels.TRACE) {\n      console.trace(msg);\n    }\n  },\n\n  /**\n   * Log a debug message.\n   * Careful: depends on console settings.\n   *\n   * @param {string} msg The message to log.\n   */\n  debug: function (msg) {\n    if (this.level <= this.levels.DEBUG) {\n      console.debug(msg);\n    }\n  },\n\n  /**\n   * Log an info message.\n   *\n   * @param {string} msg The message to log.\n   */\n  info: function (msg) {\n    if (this.level <= this.levels.INFO) {\n      console.info(msg);\n    }\n  },\n\n  /**\n   * Log a warn message.\n   *\n   * @param {string} msg The message to log.\n   */\n  warn: function (msg) {\n    if (this.level <= this.levels.WARN) {\n      console.warn(msg);\n    }\n  },\n\n  /**\n   * Log an error message.\n   *\n   * @param {string} msg The message to log.\n   */\n  error: function (msg) {\n    if (this.level <= this.levels.ERROR) {\n      console.error(msg);\n    }\n  }\n\n}; // logger\n","import {Vector3D} from './vector.js';\nimport {Point3D} from './point.js';\nimport {Index} from './index.js';\nimport {logger} from '../utils/logger.js';\n\n/**\n * List of compatible typed arrays.\n *\n * @typedef {(\n *   Uint8Array | Int8Array |\n *   Uint16Array | Int16Array |\n *   Uint32Array | Int32Array\n * )} TypedArray\n */\n\n// Number.EPSILON is difference between 1 and the smallest\n// floating point number greater than 1\n// -> ~2e-16\n// BIG_EPSILON -> ~2e-12\nexport const BIG_EPSILON = Number.EPSILON * 1e4;\nexport const BIG_EPSILON_EXPONENT = 12;\n// 'real world', for example when comparing positions\nexport const REAL_WORLD_EPSILON = 1e-4;\nexport const REAL_WORLD_EXPONENT = 5;\n\n/**\n * Check if two numbers are similar.\n *\n * @param {number} a The first number.\n * @param {number} b The second number.\n * @param {number} [tol] Optional comparison tolerance,\n *   defaults to Number.EPSILON.\n * @returns {boolean} True if similar.\n */\nexport function isSimilar(a, b, tol) {\n  if (typeof tol === 'undefined') {\n    tol = Number.EPSILON;\n  }\n  return Math.abs(a - b) < tol;\n}\n\n/**\n * Immutable 3x3 Matrix.\n */\nexport class Matrix33 {\n\n  /**\n   * Matrix values.\n   *\n   * @type {number[]}\n   */\n  #values;\n\n  /**\n   * Matrix inverse, calculated at first ask.\n   *\n   * @type {Matrix33}\n   */\n  #inverse;\n\n  /**\n   * @param {number[]} values Row-major ordered 9 values.\n   */\n  constructor(values) {\n    this.#values = values;\n  }\n\n  /**\n   * Get a value of the matrix.\n   *\n   * @param {number} row The row at wich to get the value.\n   * @param {number} col The column at wich to get the value.\n   * @returns {number|undefined} The value at the position.\n   */\n  get(row, col) {\n    return this.#values[row * 3 + col];\n  }\n\n  /**\n   * Get the inverse of this matrix.\n   *\n   * @returns {Matrix33|undefined} The inverse matrix or undefined\n   *   if the determinant is zero.\n   */\n  getInverse() {\n    if (typeof this.#inverse === 'undefined') {\n      this.#inverse = getMatrixInverse(this);\n    }\n    return this.#inverse;\n  }\n\n  /**\n   * Check for Matrix33 equality.\n   *\n   * @param {Matrix33} rhs The other matrix to compare to.\n   * @returns {boolean} True if both matrices are equal.\n   */\n  equals(rhs) {\n    // TODO: add type check\n    // check values\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        if (this.get(i, j) !== rhs.get(i, j)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Check for Matrix33 similarity.\n   *\n   * @param {Matrix33} rhs The other matrix to compare to.\n   * @param {number} [tol] Optional number comparison tolerance,\n   *   defaults to Number.EPSILON.\n   * @returns {boolean} True if both matrices are similar.\n   */\n  isSimilar(rhs, tol) {\n    // TODO: add type check\n    // check values\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        if (!isSimilar(this.get(i, j), rhs.get(i, j), tol)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get a string representation of the Matrix33.\n   *\n   * @returns {string} The matrix as a string.\n   */\n  toString() {\n    let str = '[';\n    for (let i = 0; i < 3; ++i) {\n      if (i !== 0) {\n        str += ', \\n ';\n      }\n      for (let j = 0; j < 3; ++j) {\n        if (j !== 0) {\n          str += ', ';\n        }\n        str += this.get(i, j);\n      }\n    }\n    str += ']';\n    return str;\n  }\n\n  /**\n   * Multiply this matrix by another.\n   *\n   * @param {Matrix33} rhs The matrix to multiply by.\n   * @returns {Matrix33} The product matrix.\n   */\n  multiply(rhs) {\n    const values = [];\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        let tmp = 0;\n        for (let k = 0; k < 3; ++k) {\n          tmp += this.get(i, k) * rhs.get(k, j);\n        }\n        values.push(tmp);\n      }\n    }\n    return new Matrix33(values);\n  }\n\n  /**\n   * Get the absolute value of this matrix.\n   *\n   * @returns {Matrix33} The result matrix.\n   */\n  getAbs() {\n    const values = [];\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        values.push(Math.abs(this.get(i, j)));\n      }\n    }\n    return new Matrix33(values);\n  }\n\n  /**\n   * Multiply this matrix by a 3D array.\n   *\n   * @param {number[]} array3D The input 3D array.\n   * @returns {number[]} The result 3D array.\n   */\n  multiplyArray3D(array3D) {\n    if (array3D.length !== 3) {\n      throw new Error('Cannot multiply 3x3 matrix with non 3D array: ' +\n        array3D.length);\n    }\n    const values = [];\n    for (let i = 0; i < 3; ++i) {\n      let tmp = 0;\n      for (let j = 0; j < 3; ++j) {\n        tmp += this.get(i, j) * array3D[j];\n      }\n      values.push(tmp);\n    }\n    return values;\n  }\n\n  /**\n   * Multiply this matrix by a 3D typed array.\n   *\n   * @param {TypedArray} sourceArray The input 3D array.\n   * @param {TypedArray} outArray The array to write to.\n   */\n  multiplyTypedArray3D(sourceArray, outArray) {\n    for (let i = 0; i < 3; ++i) {\n      outArray[i] = 0;\n      for (let j = 0; j < 3; ++j) {\n        outArray[i] += this.get(i, j) * sourceArray[j];\n      }\n    }\n  }\n\n  /**\n   * Multiply this matrix by a 3D vector.\n   *\n   * @param {Vector3D} vector3D The input 3D vector.\n   * @returns {Vector3D} The result 3D vector.\n   */\n  multiplyVector3D(vector3D) {\n    const array3D = this.multiplyArray3D(\n      [vector3D.getX(), vector3D.getY(), vector3D.getZ()]\n    );\n    return new Vector3D(array3D[0], array3D[1], array3D[2]);\n  }\n\n  /**\n   * Multiply this matrix by a 3D point.\n   *\n   * @param {Point3D} point3D The input 3D point.\n   * @returns {Point3D} The result 3D point.\n   */\n  multiplyPoint3D(point3D) {\n    const array3D = this.multiplyArray3D(\n      [point3D.getX(), point3D.getY(), point3D.getZ()]\n    );\n    return new Point3D(array3D[0], array3D[1], array3D[2]);\n  }\n\n  /**\n   * Multiply this matrix by a 3D index.\n   *\n   * @param {Index} index3D The input 3D index.\n   * @returns {Index} The result 3D index.\n   */\n  multiplyIndex3D(index3D) {\n    const array3D = this.multiplyArray3D(index3D.getValues());\n    return new Index(array3D);\n  }\n\n  /**\n   * Get the index of the maximum in absolute value of a row.\n   *\n   * @param {number} row The row to get the maximum from.\n   * @returns {object} The {value,index} of the maximum.\n   */\n  getRowAbsMax(row) {\n    const values = [\n      Math.abs(this.get(row, 0)),\n      Math.abs(this.get(row, 1)),\n      Math.abs(this.get(row, 2))\n    ];\n    const absMax = Math.max.apply(null, values);\n    const index = values.indexOf(absMax);\n    return {\n      value: this.get(row, index),\n      index: index\n    };\n  }\n\n  /**\n   * Get the index of the maximum in absolute value of a column.\n   *\n   * @param {number} col The column to get the maximum from.\n   * @returns {object} The {value,index} of the maximum.\n   */\n  getColAbsMax(col) {\n    const values = [\n      Math.abs(this.get(0, col)),\n      Math.abs(this.get(1, col)),\n      Math.abs(this.get(2, col))\n    ];\n    const absMax = Math.max.apply(null, values);\n    const index = values.indexOf(absMax);\n    return {\n      value: this.get(index, col),\n      index: index\n    };\n  }\n\n  /**\n   * Get this matrix with only zero and +/- ones instead of the maximum.\n   *\n   * @returns {Matrix33} The simplified matrix.\n   */\n  asOneAndZeros() {\n    // TODO: This breaks at 45 degree angles\n    const res = [];\n    for (let j = 0; j < 3; ++j) {\n      const max = this.getRowAbsMax(j);\n      const sign = max.value > 0 ? 1 : -1;\n      for (let i = 0; i < 3; ++i) {\n        if (i === max.index) {\n          res.push(1 * sign);\n        } else {\n          res.push(0);\n        }\n      }\n    }\n    return new Matrix33(res);\n  }\n\n  /**\n   * Get the third column direction index of an orientation matrix.\n   *\n   * @returns {number} The index of the absolute maximum of the last column.\n   */\n  getThirdColMajorDirection() {\n    return this.getColAbsMax(2).index;\n  }\n\n  /**\n   * Get the values of the matrix as an array.\n   *\n   * @returns {number[]} The matrix.\n   */\n  getValues() {\n    return this.#values.slice();\n  }\n\n} // Matrix33\n\n/**\n * Get the inverse of an input 3*3 matrix.\n *\n * Ref:\n * - {@link https://en.wikipedia.org/wiki/Invertible_matrix#Inversion_of_3_%C3%97_3_matrices},\n * - {@link https://github.com/willnode/N-Matrix-Programmer}.\n *\n * @param {Matrix33} m The input matrix.\n * @returns {Matrix33|undefined} The inverse matrix or undefined\n *   if the determinant is zero.\n */\nfunction getMatrixInverse(m) {\n  const m00 = m.get(0, 0);\n  const m01 = m.get(0, 1);\n  const m02 = m.get(0, 2);\n  const m10 = m.get(1, 0);\n  const m11 = m.get(1, 1);\n  const m12 = m.get(1, 2);\n  const m20 = m.get(2, 0);\n  const m21 = m.get(2, 1);\n  const m22 = m.get(2, 2);\n\n  const a1212 = m11 * m22 - m12 * m21;\n  const a2012 = m12 * m20 - m10 * m22;\n  const a0112 = m10 * m21 - m11 * m20;\n\n  let det = m00 * a1212 + m01 * a2012 + m02 * a0112;\n  if (det === 0) {\n    logger.warn('Cannot invert 3*3 matrix with zero determinant.');\n    return undefined;\n  }\n  det = 1 / det;\n\n  const values = [\n    det * a1212,\n    det * (m02 * m21 - m01 * m22),\n    det * (m01 * m12 - m02 * m11),\n    det * a2012,\n    det * (m00 * m22 - m02 * m20),\n    det * (m02 * m10 - m00 * m12),\n    det * a0112,\n    det * (m01 * m20 - m00 * m21),\n    det * (m00 * m11 - m01 * m10)\n  ];\n\n  return new Matrix33(values);\n}\n\n/**\n * Create a 3x3 identity matrix.\n *\n * @returns {Matrix33} The identity matrix.\n */\nexport function getIdentityMat33() {\n  /* eslint-disable @stylistic/js/array-element-newline */\n  return new Matrix33([\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1\n  ]);\n  /* eslint-enable @stylistic/js/array-element-newline */\n}\n\n/**\n * Check if a matrix is a 3x3 identity matrix.\n *\n * @param {Matrix33} mat33 The matrix to test.\n * @returns {boolean} True if identity.\n */\nexport function isIdentityMat33(mat33) {\n  return mat33.equals(getIdentityMat33());\n}\n","\nimport {Matrix33, BIG_EPSILON} from '../math/matrix.js';\n\n/**\n * Get the first value of an array.\n *\n * @param {number[]} values The input array.\n * @returns {number} The first value.\n */\nfunction get0(values) {\n  return values[0];\n};\n/**\n * Get the second value of an array.\n *\n * @param {number[]} values The input array.\n * @returns {number} The second value.\n */\nfunction get1(values) {\n  return values[1];\n};\n/**\n * Get a weighting func.\n *\n * @param {number} weight The weight.\n * @returns {Function} The weight function.\n */\nfunction getWeightFunc(weight) {\n  return (values) =>\n    (values[1] * weight) + (values[0] * (1 - weight));\n}\n\nexport class ResamplingFilter {\n  /**\n   * Simple bilinear sampling function.\n   *\n   * @param {TypedArray} buffer The buffer to sample.\n   * @param {number[]} unitVectors The buffer offset space unit vectors.\n   * @param {number[]} size The buffer size.\n   * @param {number[]} point The index space point to sample.\n   *\n   * @returns {number} The sampled value.\n   */\n  #bilinearSample(buffer, unitVectors, size, point) {\n    const q0IndexX = Math.floor(point[0]);\n    const q0IndexY = Math.floor(point[1]);\n    const q0IndexZ = Math.floor(point[2]);\n\n    const wx = Math.abs(point[0] - q0IndexX);\n    const wy = Math.abs(point[1] - q0IndexY);\n    const wz = Math.abs(point[2] - q0IndexZ);\n\n    let getYMean = getWeightFunc(wz);\n    if (q0IndexZ < 0) {\n      getYMean = get1;\n    } else if (q0IndexZ + 1 >= size[2]) {\n      getYMean = get0;\n    }\n\n    let getXMean = getWeightFunc(wy);\n    if (q0IndexY < 0) {\n      getXMean = get1;\n    } else if (q0IndexY + 1 >= size[1]) {\n      getXMean = get0;\n    }\n\n    let getMean = getWeightFunc(wx);\n    if (q0IndexX < 0) {\n      getMean = get1;\n    } else if (q0IndexX + 1 >= size[0]) {\n      getMean = get0;\n    }\n\n    let zIndex;\n    let offX, offXY;\n    const xMeans = [0.0, 0.0];\n    let yMeans, zValues;\n    for (let x = 0; x < 2; x++) {\n      offX = (q0IndexX + x) * unitVectors[0];\n      yMeans = [0.0, 0.0];\n      for (let y = 0; y < 2; y++) {\n        offXY = offX + (q0IndexY + y) * unitVectors[1];\n        zValues = [0.0, 0.0];\n        for (let z = 0; z < 2; z++) {\n          zIndex = q0IndexZ + z;\n          if (\n            zIndex >= 0 && zIndex < size[2]\n          ) {\n            zValues[z] = buffer[offXY + zIndex * unitVectors[2]];\n          } else {\n            zValues[z] = 0;\n          }\n        }\n        yMeans[y] = getYMean(zValues);\n      }\n      xMeans[x] = getXMean(yMeans);\n    }\n\n    return getMean(xMeans);\n  }\n\n  /**\n   * Round if the value is close enough to an integer.\n   *\n   * @param {number} value The value to round.\n   * @returns {number} The rounded value.\n   */\n  #snapRound(value) {\n    const rounded = Math.round(value);\n    return Math.abs(value - rounded) < BIG_EPSILON ? rounded : value;\n  }\n\n  /**\n   * Calculate the resampling.\n   *\n   * @param {object} workerMessage The worker message.\n   */\n  calculateResample(workerMessage) {\n    const sourceSize = workerMessage.sourceSize;\n    const targetSize = workerMessage.targetSize;\n    const sourceUnitVectors = workerMessage.sourceUnitVectors;\n    const targetUnitVectors = workerMessage.targetUnitVectors;\n    const sourceSpacing = workerMessage.sourceSpacing;\n    const targetSpacing = workerMessage.targetSpacing;\n\n    const interpolate = workerMessage.interpolate;\n\n    // Can't pass them in as matrixes, so we need to re-create them\n    const sourceMatrix = new Matrix33(workerMessage.sourceOrientation);\n    const targetMatrix = new Matrix33(workerMessage.targetOrientation);\n\n    const invSourceMatrix = sourceMatrix.getInverse();\n    const relativeMatrix = targetMatrix.multiply(invSourceMatrix);\n\n    const halfTargetSize = [\n      (targetSize[0] - 1) / 2.0,\n      (targetSize[1] - 1) / 2.0,\n      (targetSize[2] - 1) / 2.0\n    ];\n\n    const halfSourceSize = [\n      (sourceSize[0] - 1) / 2.0,\n      (sourceSize[1] - 1) / 2.0,\n      (sourceSize[2] - 1) / 2.0\n    ];\n\n    const centeredIndexPoint = new Array(3);\n    const rotIndexPoint = new Array(3);\n\n    let sx, sy, sz;\n    let targetOffX, targetOffXY, targetOffset;\n    for (let x = 0; x < targetSize[0]; x++) {\n      centeredIndexPoint[0] = (x - halfTargetSize[0]) * targetSpacing[0];\n      targetOffX = targetUnitVectors[0] * x;\n      for (let y = 0; y < targetSize[1]; y++) {\n        centeredIndexPoint[1] = (y - halfTargetSize[1]) * targetSpacing[1];\n        targetOffXY = targetOffX + targetUnitVectors[1] * y;\n        for (let z = 0; z < targetSize[2]; z++) {\n          centeredIndexPoint[2] = (z - halfTargetSize[2]) * targetSpacing[2];\n\n          relativeMatrix.multiplyTypedArray3D(\n            centeredIndexPoint, rotIndexPoint\n          );\n\n          sx = this.#snapRound(\n            (rotIndexPoint[0] / sourceSpacing[0]) + halfSourceSize[0]\n          );\n          sy = this.#snapRound(\n            (rotIndexPoint[1] / sourceSpacing[1]) + halfSourceSize[1]\n          );\n          sz = this.#snapRound(\n            (rotIndexPoint[2] / sourceSpacing[2]) + halfSourceSize[2]\n          );\n\n          if (\n            sx >= 0 && sx < sourceSize[0] &&\n            sy >= 0 && sy < sourceSize[1] &&\n            sz >= 0 && sz < sourceSize[2]\n          ) {\n            targetOffset = targetOffXY + targetUnitVectors[2] * z;\n\n            if (interpolate) {\n              // Bilinear\n              const sample = this.#bilinearSample(\n                workerMessage.sourceImageBuffer,\n                sourceUnitVectors,\n                sourceSize,\n                [sx, sy, sz]\n              );\n              workerMessage.targetImageBuffer[targetOffset] = sample;\n\n            } else {\n              // Nearest Neighbor\n              const inOffset =\n                (sourceUnitVectors[0] * Math.round(sx)) +\n                (sourceUnitVectors[1] * Math.round(sy)) +\n                (sourceUnitVectors[2] * Math.round(sz));\n\n              workerMessage.targetImageBuffer[targetOffset] =\n                workerMessage.sourceImageBuffer[inOffset];\n            }\n          }\n        }\n      }\n    }\n  }\n}","/**\n * Resampling filter worker.\n */\n\nimport {ResamplingFilter} from './resamplingFilter.js';\n\nself.addEventListener('message', function (event) {\n\n  const filter = new ResamplingFilter();\n  filter.calculateResample(event.data);\n  self.postMessage(event.data);\n}, false);"],"names":["Vector3D","constructor","x","y","z","this","getX","getY","getZ","equals","rhs","toString","norm","Math","sqrt","crossProduct","vector3D","dotProduct","isCodirectional","Point3D","getValues","isSimilar","tol","getDistance","point3D","dx","dy","dz","getClosest","pointList","minIndex","minDist","i","length","dist","minus","Index","values","Error","every","val","isNaN","get","slice","canCompare","leni","compare","diffDims","push","add","dim","value","console","warn","next","previous","getWithNew2D","j","l","lenl","logger","levels","TRACE","DEBUG","INFO","WARN","ERROR","level","trace","msg","debug","info","error","BIG_EPSILON","Number","EPSILON","a","b","abs","Matrix33","row","col","getInverse","m","m00","m01","m02","m10","m11","m12","m20","m21","m22","a1212","a2012","a0112","det","getMatrixInverse","str","multiply","tmp","k","getAbs","multiplyArray3D","array3D","multiplyTypedArray3D","sourceArray","outArray","multiplyVector3D","multiplyPoint3D","multiplyIndex3D","index3D","getRowAbsMax","absMax","max","apply","index","indexOf","getColAbsMax","asOneAndZeros","res","sign","getThirdColMajorDirection","get0","get1","getWeightFunc","weight","ResamplingFilter","buffer","unitVectors","size","point","q0IndexX","floor","q0IndexY","q0IndexZ","wx","wy","getYMean","getXMean","zIndex","offX","offXY","getMean","xMeans","yMeans","zValues","rounded","round","calculateResample","workerMessage","sourceSize","targetSize","sourceUnitVectors","targetUnitVectors","sourceSpacing","targetSpacing","interpolate","sourceMatrix","sourceOrientation","targetMatrix","targetOrientation","invSourceMatrix","relativeMatrix","halfTargetSize","halfSourceSize","centeredIndexPoint","Array","rotIndexPoint","sx","sy","sz","targetOffX","targetOffXY","targetOffset","sample","sourceImageBuffer","targetImageBuffer","inOffset","self","addEventListener","event","data","postMessage"],"sourceRoot":""}